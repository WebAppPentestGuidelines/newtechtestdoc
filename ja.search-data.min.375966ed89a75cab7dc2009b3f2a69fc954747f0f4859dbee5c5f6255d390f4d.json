[{"id":0,"href":"/docs/oauth/","title":"OAuth/OpenIDConnectの診断手法","section":"Docs","content":" OAuth/OpenIDConnectの診断手法 # 概要 # 本章では、OAuth2.0およびOpenIDConnectと、それに関連するしくみについての脆弱性や攻撃手法について説明します。 なお、本ドキュメントに記載する用語、パラメータ名などはRFC 6749およびOpenID Connect Core 1.0 incorporating errata set 1の記載に準拠します。\nOAtuh2.0 # OAuth2.0は、リソースサーバや認可サーバから見てサードパーティとなるクライアントサーバやアプリケーション等が、その認可に応じてリソースサーバに保存されているリソースオーナの情報を得るための認可フレームワークです。 通常のアプリケーションのようにクライアント/サーバだけではなく、認可サーバ/リソースサーバを含めた三者間の関係でセキュリティを考慮する必要があります。そのため、各パラメータの目的を考えながら、仕様通り正しく実装する必要があります。\n以下では代表的な脆弱性の概要や診断手法について記載します。\nオープンリダイレクタ # 概要 # 認可サーバでの認可が完了すると、リソースオーナのブラウザはredirect_uriパラメータで指定されたURLへリダイレクトされます。このリダイレクト時にオープンリダイレクタの脆弱性が存在すると、リソースオーナのブラウザが攻撃者の管理するサーバへリダイレクトされ、認可コード／アクセストークンが漏えいします。\n原因と影響 # Authorization Code Grantを利用しているネイティブアプリケーションがPKCEを利用していない、もしくは認可サーバがPKCEに対応していないことが原因です。 この攻撃によって認可コードが漏えいした場合、正規のアプリケーションになりすまして不正にアクセストークンを発行される可能性があります。\n診断観点 # 診断時においては、ネイティブアプリケーションからのOAuthのフロー開始後、PKCE関連のパラメータが送信されているか、送信されている場合にその値が適切に検証されているかを検査する必要があります。\n認可リクエストにおいては、code_challengeおよびcode_challenge_methodパラメータが送信されているかを確認します。もし送信されている場合には、いずれか一方の値を適当な値に改ざんしてもフローが正常に完了するか検査します。\nトークンリクエストにおいては、code_verifierを含めないもしくは正規のcode_verifier以外の値に改ざんしてもフローが正常に完了するか検査します。\n対策 # 認可コード横取り攻撃は認可サーバでの対策が必要です。 RFC 7636で策定されたPKCE(Proof Key for Code Exchange)に準拠した実装をします。また、自身を利用するクライアントに対して、PKCEに準拠した各パラメータの送信を必須として要求します。\nクロスサイトリクエストフォージェリ # 概要 # OAuth2.0におけるstateパラメータは、端的にはCSRF攻撃を防ぐためのパラメータです。 本パラメータに着眼して認可コードフローを見ると、以下のようになります。\nクライアントサーバは、stateとしてランダムな値を発行し、リソースオーナーのブラウザのセッションと紐づけて保存する ブラウザは、クライアントサーバから発行されたstateを含む認可サーバへのURLへアクセスする 認可サーバは、codeパラメータとともに(2)のリダイレクト時に受け取ったstateをURLに付与してブラウザをクライアントサーバへリダイレクトさせる クライアントサーバは、ブラウザからcodeとstateを受け取り、(1)で保存したstateと一致している場合は以降の処理を実施する このフローにおいてstateパラメータの検証を適切に行っていない場合、以下の手順で攻撃が可能となります。\n攻撃者は、上記フローにのっとって発行された自身のcodeを用いて、そのcodeを付与して被害者ブラウザをクライアントサーバへリダイレクトさせるような罠サイトを作る 罠サイトにアクセスした被害者のセッションと攻撃者のcodeの組をクライアントサーバで処理される 被害者は、攻撃者のアカウントでログインした状態となる 原因と影響 # 前述の通り、原因は、クライアントサーバが、codeパラメータを受け取る際に、stateパラメータを検証していないことです。 これによって、攻撃者のアカウント向けに発行されたcodeパラメータを、被害者に強制させることができます。\nこの影響はサイトや機能によって異なります。 たとえば、会員登録後に他サイトのアカウントと連携設定することで当該サイトのアカウントで会員としてログインできる機能をもったサイトの場合を考えます。この場合、連携設定の際に攻撃者アカウントのcodeを被害者のセッションに強制することで、攻撃者アカウントで当該サイトに被害者としてログインできます。\n診断観点 # 診断時においては、CSRFの観点からstateパラメータを検証する必要があります。\nOAuthはその性質上セッションを維持したまま外部サイトからのGET等を受け付ける必要があります。このため、Samesite属性によってCSRFを防いでいるサイトであっても、CSRF可能となる場合があるので、注意が必要です。\n対策 # 対策は、処理前に十分にランダムなstateを付与し、codeパラメータを処理する前にセッションから読み出したstateとリダイレクトによって送られてきたstateが同一であるかを検証することです。\nコードインジェクション # 概要 # コードインジェクションとは、攻撃者自身の管理下にあるアプリケーションに対して、OAuthまたはOIDCのリダイレクト時に認可コードを第三者の未使用の認可コードに入れ替える攻撃です。\n原因と影響 # OAuthにおいては、Authorization Code Grantを利用しているクライアントアプリがPKCEを利用していない、もしくは認可サーバがPKCEに対応していないことが原因です。 OIDCにおいては、nonceまたはc_hashを利用していないことが原因です。 攻撃者はあらかじめクライアントアプリに対して発行された、被害者となるリソースオーナーの認可コードを取得します。 そして、認可レスポンスの Location ヘッダに含まれるURIのクエリパラメータの認可コードの値をあらかじめ取得した被害者の認可コードと入れ替えます。 これにより、攻撃者はリソースオーナーのリソースに不正にアクセスできます。\n診断観点 # OAuthのフロー開始後、PKCE関連のパラメータが送信されているか、その値が適切に検証されているかを検査する必要があります。 認可リクエストにおいては、code_challengeおよびcode_challenge_method パラメータが送信されているかを確認します。 送信されている場合にはいずれか一方の値を適当な値に改ざんしてもフローが正常に完了するか検査します。 トークンリクエストにおいては、code_verifierを含めないもしくは正規のcode_verifier以外の値に改ざんしてもフローが正常に完了するか検査します。\nOIDCのフロー開始後、IDトークンのnonceまたはc_hashがクライアントアプリで適切に検証されているか検査する必要があります。 認証リクエストにおいて、nonceもしくはcodeを入れ替えることでフローが正常に完了するか検査します。\n対策 # OAuthのコードインジェクション対策として、PKCEに準拠した実装が有効です。PKCEにより認可サーバで認可コードの入れ替えを検知できます。\nOIDCのコードインジェクション対策として、nonceとc_hashがあります。 nonceを利用することで、IDトークンと認証リクエストを紐づけることが可能となります。クライアントアプリがIDトークンを受け取ったら、nonceを検証することで、トークンレスポンスにおいて攻撃を検知できます。 c_hashが利用できるのは response_typeの値にid_tokenとcodeの両方が含まれるハイブリッドフローです。クライアントアプリがIDトークンのc_hashを検証することで、認証レスポンスにおいて攻撃を検知できます。\nクライアント認証の不備 # 概要 # アクセストークンリクエストは、アクセストークン取得のためにクライアントから認可サーバ宛に送信されるリクエストです。アクセストークンリクエスト時にはクライアント認証が必須とされており、ここでの認証に不備があると、正規のクライアントになりすましてアクセストークンを発行可能となります。\n原因と影響 # 認可サーバが、アクセストークンリクエスト受信時にクライアントへ認証を要求していないことが原因です。 このような場合、何らかの手段で漏えいした認可コードを用いて、正規のクライアントになりすましたアクセストークンを発行される可能性があります。\n診断観点 # 認可サーバから得たアクセストークンをサーバに送信していたり、そのアクセストークンによって解決した情報をサーバに送信している場合は注意が必要です。その値が改ざん可能であることを留意した設計になっているか検証する必要があります。\n対策 # アクセストークンリクエスト送信時に、クライアントへ認証を要求します。ここでの認証方式は厳密に指定されておらず、パスワード認証やクライアント証明書などが利用可能です。\nImplicit Grant Flowをサーバと関係した処理で用いる # 概要 # Implicitフローは認可サーバとリソースオーナーのユーザエージェントのみで構成されるアプリケーションにおいて使える機能です。このフローで得た情報をサーバに送信する場合、当該値はリソースオーナーによって改ざん可能であるため、信頼できない値として扱う必要があります。\n原因と影響 # たとえばImplicitフローで得られたリソースオーナーの住所をサーバに送信して、リソースサーバから連携された身元情報として取り扱う場合を考えます。この場合攻撃者は、リソースサーバから得られた住所を改変して送信することで、リソースサーバによって検証されていない値を登録できます。\nまた、クライアントがアクセストークンをリソースオーナーのユーザエージェントから直接受け取っている場合、リソースオーナーは任意のアクセストークンを送信できます。よって当該クライアント向けに発行されたものであるか検証しない限り、攻撃者サーバを利用したユーザのアクセストークンを使って、対象サイト上の機能を悪用できる可能性があります。\n対策 # 認可サーバとリソースオーナのユーザエージェント以外が関与する場合はImplicitフローではなく、認可コードフローを用いてください。\nOpenID Connect # OpenIDConnectにおいても、その一部はOAuth2.0と同様の処理であるため、その共通する処理に関しては前述の問題が起こり得ます。 ただし、OpenID Connect特有の問題もあります。以下ではその問題について解説します。\nIDTokenの検証不備 # 概要 # OpenIDConnectにおいては、最終的にユーザのアイデンティティを証明するものとして、JsonWebTokenが発行されます。このトークンには発行元や発行先、有効期限などが保持されており、署名によって正当性を検証できるようになっています。 正当性検証を怠った場合、JWT改ざんによって、なりすまし等の被害を発生させる恐れがあります。\n原因と影響 # トークンの署名検証に不備がある場合、攻撃者はトークンを改ざんできるため、JWT内のパラメータを改ざんすることで、なりすますことが可能です。alg:Noneを指定できる場合や、攻撃者にとって既知の鍵を用いている場合などが不備の典型例です。\n診断観点 # alg none # 署名検証不備を狙う攻撃として著名なものにJWTヘッダのalgの値にnoneを設定し、署名検証を回避させるものがあります。IDトークンの検証者がnoneの設定を許容している場合、IDトークンに含まれるclaimの値を攻撃者が自由に改ざん可能となり、第三者へのなりすましが容易に可能となります。\nalg hs256 # noneがIdPによって拒否された場合、別のアルゴリズムを指定することで署名検証の不備を突破できる可能性があります。それはHS256です。改ざん対象のIDトークンの署名に用いられた秘密鍵と対になるIdPの公開鍵を特定し、その公開鍵を用いてIDトークンの署名を生成します。この時のIDトークンは、ヘッダのalgの値としてHS256を指定した新たなIDトークンとして生成します。署名に用いたIdPの公開鍵をkidパラメータなどで指定できる場合、IDトークンに含まれるclaimの値を攻撃者が自由に改ざん可能となり、第三者へのなりすましが容易に可能となります。\n対策 # まず署名検証を正しく行う必要があります。自身がRPの場合、署名検証アルゴリズムは独自に実装せず、ライブラリ等を用いて検証しましょう。自身がidpを担う場合は、ライブラリ使用に加え、JWT署名専用の鍵を生成・保管し鍵を使いまわさないようにしてください。 加えて、自身がRPの場合は利用しているidpが各クレームをどのように用いているか念のため確認することを推奨します。idpが推奨する利用法や実装に沿って認証機能を実装しましょう。自身がidpの場合は、仕様に沿って各クレームを実装してください。仕様書にないクレームを付与する場合は、その意味や想定される使い方を公開してください。\nリプレイアタック # 概要 # リプレイアタックとは、すでにRPで利用されたIDトークンを再送することで、正規のユーザになりすましてRPへログインすることを試みる攻撃です。 すでに利用済みのIDトークンを利用することから、正規のOIDCフローが完了した後に懸念されます。\n原因と影響 # リプレイアタックが発生する原因にはRPとOPそれぞれの実装不備が関与します。\nRP # ユーザのセッションと紐づくnonceパラメータを認証リクエストに含めていない、もしくはトークンレスポンス受信時にnonceパラメータを削除していない、のいずれか一方でも満たしていないことが原因です。\nOP # IDトークンのclaimに、認証リクエストで受け取ったnonceパラメータを含めていないことが原因です。 これによって、何らかの手段でIDトークンを入手した攻撃者によって、正規のユーザになりすましてRPへログインされる可能性があります。\n診断観点 # 診断時においては、IDトークンの再送が可能であるかを検査します。 手順として、まず一度OIDCのフローを完了してIDトークンを発行します。その後、別のユーザとしてOIDCのフローをあらためて開始し、トークンレスポンス内のIDトークンを、最初に発行したIDトークンへ置き換えます。その結果、最初にIDトークンを発行したユーザとしてRPへログインに成功する場合、リプレイアタックが可能となります。\n対策 # RPとOPのそれぞれで対策が必要です。\nRP # 以下3点のどちらの対応も必須です。\nユーザのセッションに紐づく値を生成し、認証リクエストにnonceパラメータとして含める IDトークンのclaim内のnonceパラメータとユーザのセッションに紐づく値が一致することを検証する 検証後にセッションからnonceに一致する値を削除する OP # 認証リクエストにnonceパラメータが含まれている場合は、発行するIDトークンのclaimにそのnonceパラメータをそのまま含める。\n"},{"id":1,"href":"/docs/prototype_pollution/","title":"Prototype Pollution","section":"Docs","content":" Prototype Pollution # 概要 # Prototype Pollution は、JavaScript において主に\u0026quot;継承\u0026quot;を実現するために用いられる、__proto__プロパティを通じて特定のオブジェクトの内容を不正に変更する攻撃手法またはそれに対する脆弱性です。\n影響 # Prototype Pollution の影響は様々で、発生箇所やアプリケーションのロジックに依存します。 最悪の場合ではサーバサイドでの任意コード実行に繋がることがあり、その他の場合では XSS や SQL インジェクションなどの脆弱性にも繋がる可能性があります。\n原因 # 攻撃者が__proto__プロパティなどを経由して、特定のオブジェクトの prototype を操作可能であることが Prototype Pollution の原因です。\n攻撃手法 # 実際にオブジェクトの__proto__プロパティが操作可能なケースとして、下記 2 つの例を紹介します。\nオブジェクトに対して merge や clone の操作を行うケース setValue(obj, key, value)のようにオブジェクトのプロパティを設定するケース 1. オブジェクトに対して merge や clone の操作を行うケース # 以下のmerge(tgt, src)は、引数のtgtオブジェクトにsrcのプロパティを再帰的にマージします。 この実装では与えられたオブジェクトのkeyの値をチェックしておらず、任意のkeyに対して任意の値を代入できます。(10 行目)\nfunction isObject(obj) { return obj !== null \u0026amp;\u0026amp; typeof obj === \u0026#39;object\u0026#39;; } function merge(tgt, src) { for (let key in src) { if (isObject(tgt[key]) \u0026amp;\u0026amp; isObject(src[key])) { merge(tgt[key], src[key]); } else { tgt[key] = src[key]; } } return tgt; } merge( {a: 1, b: 2}, JSON.parse(\u0026#39;{\u0026#34;__proto__\u0026#34;: {\u0026#34;polluted\u0026#34;: 1}}\u0026#39;) ); const obj = {}; console.log(obj.polluted); // =\u0026gt; 1 上記の PoC では、引数srcに{\u0026quot;__proto__\u0026quot;: {\u0026quot;polluted\u0026quot;: 1}}というオブジェクトを渡しており、10 行目でtgt[__proto__] = {\u0026quot;polluted\u0026quot;:1}のような代入が実行されることで攻撃が成功しています。\n2. setValue(obj, key, value)のようにオブジェクトのプロパティを設定するケース # 以下のsetValue(obj, key, value)は、引数のobjオブジェクトに{key:value}のプロパティを追加します。また、keyにチェーン演算子を用いて指定することで深くに位置するプロパティを追加します。\nこの実装でも引数keyの値をチェックしておらず、任意のkeyに対して任意の値を代入できます。(13 行目)\nfunction isObject(obj) { return obj !== null \u0026amp;\u0026amp; typeof obj === \u0026#39;object\u0026#39;; } function setValue(obj, key, value) { const keylist = key.split(\u0026#39;.\u0026#39;); const e = keylist.shift(); if (keylist.length \u0026gt; 0) { if (!isObject(obj[e])) obj[e] = {}; setValue(obj[e], keylist.join(\u0026#39;.\u0026#39;), value); } else { obj[key] = value; return obj; }} setValue({}, \u0026#34;__proto__.polluted\u0026#34;, 1); const a = \u0026#34;\u0026#34;; console.log(a.polluted); // =\u0026gt; 1 上記の PoC では、引数keyに__proto__.pollutedという値を渡しており、再帰的に処理されることで結果的に 13 行目でobj[__proto__][polluted] = 1のような代入が実行されることで攻撃が成功しています。\n事例紹介 # NVD - cve-2019-7609 #1106238 Stored XSS via Mermaid Prototype Pollution vulnerability #454365 Prototype pollution attack through jQuery $.extend 対策 # Prototype Pollution の対策にはいくつか方法があるため、アプリケーションの規模や副作用を考慮して、適当な対策を選択するようにしてください。 ここでは代表的な下記 5 つの方法を紹介します。\nライブラリを利用する方法 Object.freezeを使用する方法 Objectの代わりにMapを使う方法 オブジェクトの作成をObject.create(null)で行う方法 Schema validation of JSON input ライブラリを利用する方法 # 要件を満たす場合、Prototype Pollution の影響を受けずにオブジェクトに対して merge や clone を行うライブラリを利用することで防ぐことができます。\nObject.freezeを使用する方法 # Object.freeze()を使用して、Object や Object.prototype を変更できないようにすることで、prototype が意図せず汚染されないようにできます。\n下記のコードは、実際にObject.freeze()を使用して実際に対策できることを示す PoC です。\nObject.freeze(Object.prototype); Object.freeze(Object); ({}.__proto__.test = 123); console.log({}.test); // =\u0026gt; undefined なお、注意点として、（上記の PoC を実際に動かしてみてもわかる通り、）Object.freeze()によって freeze されたオブジェクトの変更は、特にエラーや例外が起こることなく失敗します。 そのため、本対策を適用し意図しない副作用が発生した場合でも、その副作用を発見するのが困難な場合があります。 したがって、この対策は（依存ライブラリを含めた）アプリケーションの現状の実装を考慮して、慎重に適用することを推奨します。\nObjectの代わりにMapを使う方法 # ES6 以降では、Objectの代わりにMapが利用できます。 Objectを単純に key/value のデータ構造を利用している場合は、それらをMapに置き換えることで、Prototype Pollution を防ぐことができます。\nオブジェクトの作成をObject.create(null)で行う方法 # Object.create()にnullを渡す方法で、prototype を引き継がないオブジェクトを作成することで、__proto__経由で prototype が汚染されることを防ぐことができます。 下記のようなコードで、実際に__proto__経由で prototype にアクセスできないことを実際に確認できます。\nvar obj = Object.create(null); console.log(obj.__proto__ === Object.prototype); // =\u0026gt; false console.log(obj.__proto__); // =\u0026gt; undefined もし{\u0026quot;a\u0026quot;: 1, \u0026quot;b\u0026quot;: 2}のような元々いくつかのプロパティを持つオブジェクトを作成する場合は、下記のようにObject.assign()を併せて利用する必要があります。\nvar obj = Object.assign(Object.create(null), { a: 1, b: 2 }); なお、このように作成されたオブジェクトの prototype はObject.prototypeの参照ではないため、hasOwnProperty()のようなObject.prototypeのメソッドはプロトタイプチェーン経由で呼び出せません。 もし、そのようなメソッドを呼び出したい場合はObject.prototype.hasOwnPropertyのように明示的に行う必要があります。\nvar obj = Object.create(null); obj.a = 1; Object.prototype.hasOwnProperty.call(obj, \u0026#34;a\u0026#34;); // =\u0026gt; true Object.create(null)による本対策を適用する場合は、このような副作用に留意してください。\nSchema validation of JSON input # JSON SchemaではadditionalProperties:falseを指定することで、想定していないプロパティを禁止することができます。 適切な JSON Scheme を用いてバリデーションを行うことで Prototype Pollution の対策ができます。\n以下は、前述の関数setValue()に対し、ajvを用いて対策を行う例です。\nconst schema = { type: \u0026#34;object\u0026#34;, properties: { // 想定しているプロパティ }, additionalProperties: false, }; const validate = ajv.compile(schema); function setValue(obj, key, value) { const keylist = key.split(\u0026#34;.\u0026#34;); const e = keylist.shift(); if (keylist.length \u0026gt; 0) { if (!isObject(obj[e])) obj[e] = {}; setValue(obj[e], keylist.join(\u0026#34;.\u0026#34;), value); } else { obj[key] = value; if (!validate(obj)) { // handling throw \u0026#34;Invalid Obj\u0026#34;; } return obj; } } setValue({}, \u0026#34;__proto__.polluted\u0026#34;, 1); // =\u0026gt; Exception raised ただし、この場合、propertiesに含んでいないプロパティは一切追加ができなくなることに注意が必要です。 任意のプロパティを受け入れつつ対策をする場合、単に追加される key に悪意のある値が指定されないように制限する対策も有効です。\nfunction setValue(obj, key, value) { const keylist = key.split(\u0026#34;.\u0026#34;); const e = keylist.shift(); if (keylist.length \u0026gt; 0) { if (!isObject(obj[e])) obj[e] = {}; if (e !== \u0026#34;__proto__\u0026#34; \u0026amp;\u0026amp; e !== \u0026#34;constructor\u0026#34;) { setValue(obj[e], keylist.join(\u0026#34;.\u0026#34;), value); } } else { obj[key] = value; return obj; } } setValue({}, \u0026#34;__proto__.polluted\u0026#34;, 1); const a = \u0026#34;\u0026#34;; console.log(a.polluted); // =\u0026gt; undefined 診断方法 # 基本的な診断方法 # これまでに説明した Prototype Pollution の基本原理や攻撃手法などを踏まえ、任意のオブジェクトの prototype が不正に変更できないかを検証してください。\nDOM Invader を用いた効率的な診断 # DOM Invader は Burp の機能で DOM XSS のテストやpostMessage()の操作を用いたテストの支援を提供します。この機能を用いることでクライアントサイドの Prototype Pollution の自動検出や手動での検証の補助として利用可能です。\n詳しい検証方法はTesting for client-side prototype pollutionで丁寧に解説されているので、こちらを参照してください。\n学習方法/参考文献 # HoLyVieR/prototype-pollution-nsec18: Content released at NorthSec 2018 for my talk on prototype pollution Olivier Arteau \u0026ndash; Prototype pollution attacks in NodeJS applications - YouTube Node.js における prototype 汚染攻撃への対策 - SST エンジニアブログ 【1 分見て】実例から学ぶ prototype pollution【kurenaif 勉強日記】 - YouTube Prototype pollution: The dangerous and underrated vulnerability impacting JavaScript applications | The Daily Swig BlackFan/client-side-prototype-pollution: Prototype Pollution and useful Script Gadgets Object.prototype.proto - JavaScript | MDN "},{"id":2,"href":"/docs/toctou/","title":"Template","section":"Docs","content":" TOCTOU/レースコンディション # 概要 # システム開発のセキュリティにおいてレースコンディションとTOCTOUは、しばしば混同して使われることがありますが、それぞれの違いについて用語の整理から確認していきましょう。\nレースコンディション(race condition)とは、複数の処理が同じデータに対して同時にアクセスしたときに競合状態になることで、想定外の処理が引き起こされる問題です。\n対してTime Of Check To Time Of Use(TOCTOU)とは、あるデータを使用する際に、データの状態をチェックする処理から実際にそのデータを使用する処理するまでの間に、データの状態が変化してしまうことで想定外の処理が引き起こされる問題です。\n要約すると、レースコンディションは様々な競合状態の問題を表す包括的な脆弱性なのに対し、TOCTOUはより実装の状況を限定した具体的な脆弱性であることが分かります。\n本章では、主にTOCTOUに関連する脆弱性や攻撃手法について説明します。\n原因 # TOCTOUは主にデータのチェックとそのデータの使用するタイミングが異なっていることに起因しています。 そのため、TOCTOUを対策する考え方としては、データのチェックと使用を同時に行い、処理の差を発生させないようにすることが理想的です。\n影響 # 代表的な脅威の例として、許可されていないデータへのアクセスや、回数制限などを超えて実行することを許してしまうような影響が考えられますが、データの内容や重要性、アプリケーションの振る舞いなどのビジネスロジックによってTOCTOUによる影響範囲は大きく異なります。\nここでは、TOCTOUが発生しやすい機能を例にあげます。\n送金処理 クーポンやキャンペーンコード等の発行や使用 アカウントの新規登録 高評価、いいねボタンなどの投票機能 診断観点/攻撃手法 # 一般的に、DASTのようなツールを使用してTOCTOUの脆弱性を特定することは困難です。\nこれは、競合状態を引き起こした状態と正常なWebアプリケーションの振る舞いの違いを機械的に判断することは難しいためです。\nまた、TOCTOUの検査を行うためにはミリ秒単位で調整されたリクエスト送信や単一のHTTPパイプライン内で複数のHTTPリクエストを送る検査が必要になってくるため、Webアプリケーション診断に特化した専門ツール(Burpなど)が必要になるでしょう。\nこのように、競合状態を起こすための条件や環境を整える必要がある性質上、手動によるテストも他のWebアプリケーション脆弱性検査に比べて検査が難しいと考えられています。\nTOCTOUの脆弱性を見つけるためには、データのチェック処理とデータを使用する処理が別のタイミングで行われている箇所を探しましょう。\n具体的には、実行回数に制限があるような機能や重複防止の制限が設けられている機能などでTOCTOUの検査を行うことが有用です。\nBurp Intruderを使用した検査 # Burp Intruderを使用してTOCTOUの検査を確認するパターンを紹介します。Burp IntruderはBurpに搭載されている機能の一つですが、Community Editionには機能制限があるためPro Editionでしか検査が行えません。Community Editionを使用する場合は、後述するTurbo Intruderを使用した検査方法をご覧ください。\nはじめに、送信したいリクエストをBurp Intruderにセットします。\nBurp Intruderを開始するにはペイロードポジションを設定する必要がありますが、ペイロードによる作用を防ぐため、ここではダミー用のリクエストヘッダー(x-dummy)を用意し、ダミー用ヘッダーの値にペイロードポジションを設定します。\n次に、ペイロードの設定を行います。\nPayload TypeをNull payloadsに設定します。\nGenerateの空白欄に送信したいリクエスト数を入力します。\nデフォルトでは同時に10リクエストを送信します。\nより多くのリクエストを送信したい場合は、Resource Pool設定から新しいリソースプール設定を作成し、Maximum concurrent requestsを設定してください。\nTurbo Intruderを使用した検査 # Burp Suiteの拡張機能として公開されているTrubo Intruderを使用したパターンを紹介します。\nTurbo Intruderは、大量のHTTPリクエストを送信したり、Pythonを使用して柔軟にリクエスト前後の処理を操作することができる拡張機能です。\nまた、Turbo Intruderは、標準のBurp Intruderとは異なりCommunity Editionでも使用することが可能です。\n注意\nTurbo Intruderは、Port Swigger社のセキュリティリサーチャーであるJames Kettle氏によって開発されていますが、十分なテストが行われていないためBurpの標準機能よりも信頼性がなく、システムパフォーマンスに影響を及ぼす可能性があるため、拡張機能を使用される際には自己責任でお願い致します。 送信したいリクエストを選択し、コンテキストメニューからExtensions-\u0026gt;Turbo Intruder-\u0026gt;Send to turbo intruderをクリックして、Turbo Intruderへリクエストを送ります。\n別のウィンドウが表示されます。\nTurbo IntruderもBurp Intruderと同様にペイロードポジションを設定する必要があります。ここではダミー用のリクエストヘッダー(x-dummy)を用意し、ダミー用ヘッダーの値に%sをセットしてペイロードポジションを設定します。\n次にドロップダウンリストから「examples/race.py」を選択します。\nデフォルトでは同時に30リクエスト送信する設定になっています。例として10リクエスト送信したい場合は、9行目のrange関数の引数を修正します。\n事例紹介 # https://github.com/reddelexc/hackerone-reports/blob/master/tops_by_bug_type/TOPRACECONDITION.md 対策 # データの整合性を保つ設計を行う必要があります。しかしながら、Webアプリケーション毎によって実装やデザインが異なるため、具体的な方法は多岐に分かれます。\n考えられる対策として、データのチェックからデータ更新までの一連の処理が完了するまで、他のスレッドやプロセスからアクセスできないようにしてください。\nデータベースで管理している場合はトランザクションを行い、読み書きする情報にロックを掛ける実装にしてください。\nただし、ロックの範囲が広すぎると脆弱性発生箇所とは異なる箇所でデッドロックが発生したり、トランザクション処理によってパフォーマンスにも影響を及ぼす可能性があるため注意してください。\n学習方法/参考文献 # https://timegaptheory.com/index.html "},{"id":3,"href":"/docs/cloudsec/cloud_credential/","title":"Webアプリケーションの脆弱性を利用した認証情報の窃取","section":"クラウドサービスにおけるWebサービスにまつわる脆弱性","content":" Webアプリケーションの脆弱性を利用した認証情報の窃取 # 概要 # クラウド環境を利用してWebサービスを提供するシステムにおいて、Webアプリケーションに作りこまれた脆弱性を悪用されて、クラウドサービス側の認証情報（認証キー・APIトークンなど）を窃取されてしまう可能性が危険視されています。 これらの認証情報が漏洩した場合には、漏洩した認証情報に紐ずく権限を利用され、クラウドプラットフォーム側の機能を悪用されてしまう危険性があります。\n原因と影響 # 認証情報の種類や存在する場所などについては、利用しているクラウドプラットフォームやサービスの種類によって異なりますが、システム内の環境変数・設定ファイルなどにこれらの認証情報が設定されているケースが多く、例えば以下のような従来から存在するWebアプリケーションの脆弱性を利用されることによって窃取されてしまう危険性があります。\nWebアプリケーションにて詳細情報を表示するエラー画面などから環境変数に設定された認証情報が漏洩 ディレクトリトラバーサルの脆弱性を利用されて、設定ファイルに記載された認証情報が漏洩 また、AWSなどのパブリッククラウドサービスではメタデータサービスと呼ばれる機能が存在します。この機能では、メタデータと呼ばれるインスタンス固有のデータ(インスタンスID、OSデータ、一時的に付与される認証情報など)を内部WebAPIを通じて取得するといった仕組みが提供されています。クラウド環境にて提供されるWebアプリケーションにおいてSSRF(Server Side Request Forgery)の脆弱性が存在する場合には、この機能を悪用されてメタデータを不正に取得され、認証情報を窃取されてしまう攻撃手法が知られています。\n診断観点 # 本記事ではAWS環境を題材にSSRFを脆弱性を利用して、認証情報を取得する流れについて紹介します。\nSSRFは、攻撃者が指定した任意のサーバーに対してHTTPリクエストを行うように、サーバーサイドアプリケーションを誘導させるというものです。 これを利用して、攻撃者は脆弱性の存在するサーバーを踏み台として他サーバーにアクセスしたり、自身が直接到達することができないサーバーに対してアクセスすることができます。\n脆弱性の例として、以下のPHPのサンプルコードを用意しました。\n\u0026lt;?php\rif (isset($_GET[\u0026#39;url\u0026#39;])){\r$url = $_GET[\u0026#39;url\u0026#39;];\r$conn = curl_init();\rcurl_setopt($conn, CURLOPT_URL, $url);\rcurl_setopt($conn, CURLOPT_RETURNTRANSFER, true);\r$res = curl_exec($conn);\recho $res;\rcurl_close($conn);\r}\r?\u0026gt; GETパラメータで取得したURL値に対して、PHPのcURL関数によりHTTPリクエストを送信し、結果を出力するだけのシンプルなコードです。 もしこのようなWebアプリケーションが存在し、公開されていた場合にはSSRF攻撃を受けてしまう可能性があります。 上記で説明したように、このWebアプリケーションではurlパラメータに指定した値をそのままcURL関数にて取得する実装となっているため、クライアント側がurlパラメータに任意のURL値を指定して受け渡すことで、Webアプリケーションに指定したURLの対象に対してアクセスさせ、レスポンスを取得することが可能です。\nこの挙動を利用することで、以下の図のように攻撃者は本来アクセスできないような対象に対して、Webアプリケーションを経由してアクセスを行い、情報を取得することが可能となります。 これは、SSRFを用いた内部ネットワークへの攻撃の一例となります。\nもし、クラウド環境にて提供されているWebアプリケーションに上記のようなSSRFの脆弱性が存在する場合には、この機能を悪用され、メタデータを不正に取得されてしまう可能性があります。以下の図では、AWS環境におけるSSRF攻撃を記載しています。\n図ではIAMロールが紐づいた状態のEC2インスタンスにおけるSSRF攻撃によって、Webアプリケーション側がメタデータサーバーのAPIへ一時的な認証情報を要求するリクエストを強制させられ、EC２のIAMロールに紐づいた認証情報を窃取されてしまう流れを記載しています。ここでは、EC2にアタッチされているIAMロールに関連付けられた認証情報を、この図のようなSSRF攻撃によって取得する流れの詳細を説明します。\nAWSのメタデータサーバーに関する仕様は以下に記載されています。\nインスタンスメタデータとユーザーデータ EC2インスタンス上より上記仕様に記載されているURLにアクセスすることで、該当するメタデータの情報を取得することができます。EC2インスタンスにアタッチされたIAMロールが存在する場合には、以下のメタデータサーバーのURLにアクセスすることで、認証情報を取得することができます。\nhttp://169.254.169.254/latest/meta-data/iam/security-credentials/[role-name] 上記のパス中の[role-name]の部分にはEC2にアタッチされているIAMロールの名前を指定する必要があります。上記URLにアクセスすることで指定したIAMロールに関連付けられた一時的なセキュリティ認証情報が格納される仕様となっています。なお、IAMロール名は以下のURLアクセスすることで取得することが可能です。\nhttp://169.254.169.254/latest/meta-data/iam/security-credentials/ AWSのEC2上でSSRFの脆弱性が存在するサンプルコードのWebアプリケーション(ssrf.php)が動作しているとします。 攻撃の流れとしては、まずSSRFの脆弱性を利用してメタデータサーバーのURLをパラメータ値として脆弱性の存在するWebアプリケーションに送信することによって、EC2にアタッチされたrole-nameを取得します。\nリクエストURL ssrf.php?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/ レスポンス HTTP/1.1 200 OK\rDate: Wed, 22 Feb 2023 17:22:20 GMT\rServer: Apache/2.4.55 () PHP/5.4.16\rUpgrade: h2,h2c\rConnection: Upgrade, close\rX-Powered-By: PHP/5.4.16\rContent-Length: 7\rContent-Type: text/html; charset=UTF-8\rec2role そして、取得したrole-nameを利用してパスの一部を変更したURLの値を送信します。同じようにSSRFの脆弱性を利用してWebアプリケーションに送信したURLにアクセスさせるように仕向けることで、以下のように一時的に発行された認証情報を取得することができます。\nリクエストURL ssrf.php?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/ec2role レスポンス HTTP/1.1 200 OK\rDate: Wed, 22 Feb 2023 17:23:48 GMT\rServer: Apache/2.4.55 () PHP/5.4.16\rUpgrade: h2,h2c\rConnection: Upgrade, close\rX-Powered-By: PHP/5.4.16\rContent-Length: 1450\rContent-Type: text/html; charset=UTF-8\r{\r\u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34;,\r\u0026#34;LastUpdated\u0026#34; : \u0026#34;2023-02-22T17:22:41Z\u0026#34;,\r\u0026#34;Type\u0026#34; : \u0026#34;AWS-HMAC\u0026#34;,\r\u0026#34;AccessKeyId\u0026#34; : \u0026#34;ASIAXXXXXXXXXXXXXXXX\u0026#34;,\r\u0026#34;SecretAccessKey\u0026#34; : \u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;,\r\u0026#34;Token\u0026#34; : \u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;,\r\u0026#34;Expiration\u0026#34; : \u0026#34;2023-02-22T23:56:46Z\u0026#34;\r} ※認証情報の部分は伏字としています。\nこのようにして、SSRF攻撃によって認証情報を取得されてしまった場合には、取得された認証情報に紐づく権限を悪用され、被害が拡大してしまう可能性があります。 また、上記のサンプルコードで送信したURL値の処理に起因するような脆弱性ではなくとも、例えば以下のような他の脆弱性が存在した場合には、その脆弱性を利用することによってアプリケーションに任意の対象にアクセスを行わせることができるため、同様の認証情報を窃取するようなSSRF攻撃を実行できる可能性があります。\nXXE OSコマンドインジェクション なお、上記はあくまで1例であり、クラウド環境のWebサービスにおける脆弱性診断では、このようにWebアプリケーションの脆弱性を利用されることによって、クラウド環境側の認証情報の取得などにつながってしまう可能性があることも想定をした上で、評価を行う必要があると考えます。従来から知られているWeb脆弱性を検出する手法についてはWebアプリケーション脆弱性診断ガイドラインをご参照ください。\nWebアプリケーション脆弱性診断ガイドライン 事例紹介 # 米金融大手Capital Oneにおける不正アクセスにおいて、WAF側の設定ミスにより、本記事にて説明しているSSRFの脆弱性を悪用され、AWS環境の認証情報を取得され、S3バケットに格納されている個人情報が漏洩してしまったという事例です。 https://piyolog.hatenadiary.jp/entry/2019/08/06/062154\n対策 # 本問題の根本的な原因となるWebアプリケーションの脆弱性については、従来通り実装・設定などによるセキュリティ対策が必要となります。個々の既知のWebアプリケーションの脆弱性に対する対策方法の詳細については、本記事での説明は割愛します。\nまた、例えばAWSにおいては以下のような設定変更を行うことで、根本的な対策ではありませんがSSRFの脆弱性に対する緩和策となることが知られています。\nIMDSv2 の使用\nhttps://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html 根本的な原因となる脆弱性への対策はもちろん必要となりますが、クラウド環境側から提供されているこのような緩和策の利用も併せて検討すべきでしょう。また、何らかの要因にて認証情報が漏洩することに備え、認証情報の不正利用に対して監視することも重要であると考えます。\n学習方法/参考文献 # SSRF(Server Side Request Forgery)徹底入門\nEC2上でDNS RebindingによるSSRF攻撃可能性を検証した\nSSRF対策としてAmazonから発表されたIMDSv2の効果と限界\n本記事にて説明したSSRFについて原理や対策方法について解説された徳丸浩さんのブログ記事です。また、本記事にて取り扱ったSSRFによるAWSの認証情報の取得についても解説されています。\nSSRF脆弱性を利用したGCE/GKEインスタンスへの攻撃例 GCP環境におけるSSRFについて解説されているブログ記事です。\nExploiting SSRF in AWS Elastic Beanstalk\nAWS Elastic Beanstalk及びAWS CodePipelineを利用している環境にてSSRFをトリガとして最終的にはRCEまで行うことができた事例について解説しているNotSoSecure社の記事です。\nPenTesterが知っている危ないAWS環境の共通点\nAWS環境において漏洩した認証情報を利用した攻撃とその対策についてまとめているスライドです。\nflaws.cloud\nflaws2.cloud\nScott Piper氏(@0xdabbad00)が常設公開されているCTF形式でAWS固有のセキュリティトピックに関して学べるサイトです。\nCloudGoat\nAWSGoat\nGCPGoat\nAzureGoat\nクラウド環境にまつわる脆弱性を学習するために、脆弱なクラウド環境を構築するためのコンテンツが公開されています。\n"},{"id":4,"href":"/docs/cloudsec/","title":"クラウドサービスにおけるWebサービスにまつわる脆弱性","section":"Docs","content":" クラウドサービスにおけるWebサービスにまつわる脆弱性 # 近年では、クラウドサービスを活用し、Webサービスを構築・提供しているという事例はもはや一般的となりました。 クラウドサービスでは、クラウド事業者側がセキュリティを担保してくれるため、利用者側は特にセキュリティを意識しなくても良いと思われるかもしれませんが、残念ながらそうではありません。\nクラウドサービスにおいては、「責任共有モデル」という考え方が存在します。 「責任共有モデル」とは利用者側・クラウド事業者側の間で、それぞれがサービス提供における担当範囲を明確にし、運用上の責任を共有するという考え方です。\nAWSの責任共有モデル\nhttps://aws.amazon.com/jp/compliance/shared-responsibility-model/ 一般的な例でいえば、IaaS(Infrastructure as a Service)においてはクラウド事業者が提供するのはインフラだけとなり、IaaSの上に構築されるOSやミドルウェア、アプリケーション、データ等に関しては、利用者側が責任を持たなければなりません。 一方PaaS(Platform as a Service)であれば、インフラ・OS・ミドルウェアはクラウド事業者が提供しますが、アプリケーション、データに関しては利用者側が責任を持たなければなりません。 上記のように、利用者とクラウド事業者の間で責任分担の境界線がしっかりと引かれており、利用者が責任を持つべき箇所が明確となっています。 これらの責任分界点については、クラウド事業者や提供するサービスによってそれぞれ定義が異なります。 なお、Cloud Security Alliance(CSA)からはコンテナやサーバーレスアーキテクチャなどの比較的新しいサービス領域についてさらに細分化した責任共有モデルなども公開されています。\nThe Evolution of Cloud Computing and the Updated Shared Responsibility\nhttps://cloudsecurityalliance.org/blog/2021/02/04/the-evolution-of-cloud-computing-and-the-updated-shared-responsibility/ 利用者側が責任を持たなければならない範囲において、誤った実装や設定上のミスなどが存在した場合には、セキュリティ上の問題となってしまう可能性があります。 現実世界でも上記が起因となって発生したセキュリティインシデントが多数報告されています。 そのため、利用者側はこういった良くありがちなセキュリティ上の問題について理解し、正しい実装・設定や問題の発生を防止するための施策を行う必要があるでしょう。\nここでは、「クラウドサービスを利用して構築しているWebサービスにおける誤った実装・設定不備などを起因としたセキュリティ上の問題点」について、近年話題となっている代表的ないくつかの事例を紹介しています。\nクラウドストレージサービスにおける設定不備 Webアプリケーションの脆弱性を利用したクラウドクレデンシャルの奪取 FaaSにおける設定不備と脆弱性の悪用 IDaaSの活用に起因する脆弱性とその悪用 "},{"id":5,"href":"/docs/cloudsec/storage_service/","title":"クラウドストレージサービスにおける設定不備","section":"クラウドサービスにおけるWebサービスにまつわる脆弱性","content":" クラウドストレージサービスにおける設定不備 # 概要 # クラウドストレージサービスとは、インターネット上にてファイルの保管・共有などができるサービスです。 画像やJavascriptファイルなどの静的ファイルを公開する用途などでも利用されています。 有名処のものとしては以下のようなサービスがあります。\nAWS S3 Azure Blob Storage Cloud Storage 近年ではこれらクラウドストレージサービスの設定ミスによるセキュリティインシデントが発生しています。\n原因と影響 # クラウドストレージサービスにおけるアクセス許可の設定不備が原因となり、意図しない情報がインターネット上に公開されてしまう可能性があります。 また、ファイルのアップロードが可能となっている場合には、公開しているコンテンツに悪意あるコードを埋め込まれ、攻撃に利用されてしまう可能性もあります。\n診断観点 # クラウドストレージの設定ミスを確認するシンプルな方法としては、クラウドストレージのエンドポイントに対応するURLに実際にアクセスし、セキュリティ上問題となるような設定やコンテンツが公開されていないかを確認をすることが挙げられます。本記事ではAWS S3を例として、脆弱性診断における本手法について説明します。\nS3バケットを示すエンドポイントのURLについて調査 # クラウドストレージを示すURLの形式に関する仕様は以下のように公開されています。\nAWS S3 Azure Blob Storage Cloud Storage ここではAWS S3について解説しますが、S3ではクラウドストレージのエンドポイントを示すURLは以下2種類のタイプが存在します。\n仮想ホスト形式\nhttp://\u0026lt;backet-name\u0026gt;.s3-\u0026lt;region\u0026gt;.amazonaws.com/ http://\u0026lt;backet-name\u0026gt;.s3.amazonaws.com/\n2019 年 3 月 20 日より後に開始されたリージョンで作成されたバケットでは2の形式(レガシーグローバルエンドポイント)では到達できないようです。 パス形式\nhttp://s3-\u0026lt;region\u0026gt;.amazonaws.com/\u0026lt;backet-name\u0026gt; http://s3.amazonaws.com/\u0026lt;backet-name\u0026gt;\n米国東部 (バージニア北部) リージョンは2の形式で、他のリージョンは1の形式となります。パス形式は将来的には廃止が検討されているようです。 上記の仕様を利用して、特定キーワードなどに関連するS3バケットのエンドポイントのURLを推測することが可能です。 また、S3バケットにおいて独自ドメインを利用して、静的なサイトをホスティングする場合には、前提としてバケット名とドメイン名が一致する必要があります。このため、Webページのドメイン名などからもエンドポイントのURLを推測をすることが可能です。\n特定のキーワードに関連するS3バケットを探索するようなツールも多数公開されています。\ns3recon s3finder また、公開状態のクラウドストレージやファイルの情報を定期的に収集し、検索できるオンラインサービスなども存在します。本サービスでは、S3だけではなくAzureやGCPなど他クラウドサービスの情報も検索できます。\nGrayhatwarfare 脆弱性診断を行う際にはクラウドストレージのエンドポイントにアクセスするために、診断対象サイトのHTMLソース・HTTPレスポンス・モバイルアプリケーションのソースコード内などに、S3バケットのURLや探索を行うためのキーワードが、存在しないかを確認すべきでしょう。なお、探索によって存在が判明したS3バケットのエンドポイントのURLが診断対象の範囲に含まれるかどうかについては、調査を行う前にあらかじめ顧客やサイト管理者に対して確認を行うべきであると考えます。\nブラウザでの確認 # ブラウザ経由でアクセスした場合に、S3バケットにおいてファイルの一覧の表示が許可されている場合には以下のようなXML形式のレスポンスが表示されます。\nこの設定状態の場合には、不特定多数にストレージ内に存在するファイルの内容が判明してしまうため、いわゆるディレクトリリスティングと同様の問題があるといえます。そのためこの設定状態が意図したものであるかを確認すべきでしょう。\nコマンドラインでの確認 # コマンドラインを用いて、クラウドストレージのファイルのダウンロードや、ファイルのアップロードについて確認することができます。\nS3バケットであればAWS CLIを利用することで上記をテストできます。 S3においては、S3バケットのACLがAll Authenticated AWS Usersと設定されている可能性もあるため、AWSユーザーとして認証された状態でもコマンドラインを実行する方が良いでしょう。\nS3バケットの内容を表示 aws s3 ls s3://\u0026lt;backet-name\u0026gt;/\u0026lt;path\u0026gt; S3バケットのオブジェクトを取得 aws s3 cp s3://\u0026lt;backet-name\u0026gt;/\u0026lt;objectname\u0026gt; \u0026lt;output file name\u0026gt; aws s3api get-object --bucket \u0026lt;bucket-name\u0026gt; --key \u0026lt;key name\u0026gt; \u0026lt;output file name\u0026gt; 設定ミスによって書き込みが可能となっている可能性があるため、以下のコマンドを利用してファイルの書き込みが可能であるかを確認できます。 正し、脆弱性診断においては、書き込みをテストしてよいか事前に顧客側に確認を行うべきであるかと考えます。\nローカルのファイルを指定して、指定したS3バケットにアップロード aws s3 cp \u0026lt;local file-path\u0026gt; s3://\u0026lt;bucket-name\u0026gt;/\u0026lt;path\u0026gt; aws s3api put-object --bucket \u0026lt;bucket-name\u0026gt; --key \u0026lt;key name\u0026gt; --body \u0026lt;local file-path\u0026gt; 事例紹介 # S3の設定不備に関するHacker Oneのレポート\nhttps://hackerone.com/reports/128088\nhttps://hackerone.com/reports/1062803 https://hackerone.com/reports/129381\nS3設定不備により機密データが公開されていた事例\nhttps://www.skyhighsecurity.com/en-us/about/resources/intelligence-digest/unsecured-servers-can-put-lives-at-stake.html https://www.safetydetectives.com/news/doctorsme-leak-report/\nAzure Blob Storageの設定不備により機密データが公開されていた事例\nhttps://www.vpnmentor.com/blog/report-microsoft-dynamics-leak/ https://www.theregister.com/2020/12/01/investment_fund_data_breach/ https://www.techradar.com/news/microsoft-azure-breach-left-thousands-of-customer-records-exposed https://www.bleepingcomputer.com/news/security/exposed-azure-bucket-leaked-passports-ids-of-volleyball-reporters/\nCloud Storageの設定不備により機密データが公開されていた事例\nhttps://www.comparitech.com/blog/information-security/google-cloud-buckets-unauthorized-access-report/\nファイルをアップロードが可能となっているような設定ミスを攻撃者に悪用された事例\nhttps://japan.zdnet.com/article/35139832/\n対策 # 公開を意図しないクラウドストレージが存在しないように、アクセス制御の設定を適切に行うようにしてください。 また、公開を意図するクラウドストレージでは、機微な情報が含まれているファイルが存在しないか確認をしてください。\n学習方法/参考文献 # Amazon S3の脆弱な利用によるセキュリティリスクと対策\n上記は本記事にて解説してるアクセス制限の設定不備を含めた、S3にまつわる脆弱性について詳細に解説したブログ記事です。本記事では取り扱っていないWebアプリケーションでS3の署名付きURLを生成している場合に脆弱性が生じてしまう事例やS3におけるサブドメインの乗っ取りなどについても解説されています。\nHunting Azure Blobs Exposes Millions of Sensitive File\nAzure Blob Storage設定不備の調査方法に関する記事です。\n"},{"id":6,"href":"/docs/nosql_injection/nosqli/","title":"Nosqli","section":"Docs","content":" NoSQL Injectionとは # NoSQLデータベースを利用したWebアプリケーションにおける脆弱性の事です。 NoSQLはより柔軟なデータ形式を使用する、SQLを利用しないデータベースシステムを指します。一般的にデータを以下の4つに管理します。 key-value型、列指向型、グラフ型、ドキュメント型の4つです。\nNoSQL Injectionの原因 # NoSQLデータベースは、SQLデータベースとは異なり、クエリを実行する際にデータを構造化された形式で保存する必要がないため、従来のSQL Injectionとは異なる形で攻撃が発生します。こういったことが起こる原因として、以下のようなものが考えられます。\n不十分な入力値の検証 クエリの構築における不適切な処理 データベースの設定不備 NoSQL Injectionが及ぼす影響 # 攻撃者はパラメータを改ざんし、データベースに意図しない挙動をさせることができます。 また、使用するnosqlの種類によっては任意のJavaScriptを実行される可能性もあります。 よって、アプリケーションの機密性、整合性、可用性を損ないます。\n事例紹介 # CVE-2021-22911 # Rocket Chatで見つかったNoSQLInjectionです。 getPasswordPolicy関数で、NoSQL Injectionが実行できます。 認証/認可を必要とせずに、パスワードリセットトークンを流出させることで、アカウントの乗っ取りが可能でした。 管理者アカウントを乗っ取ることで、RCEにつなげることも可能だったようです。\nref : https://www.cve.org/CVERecord?id=CVE-2021-22911\nCVE-2021-20736 # GROWI 日本製のOSSで見つかったNoSQL Injectionです。 Gitの編集ログをみるに、アクセストークンパーサにNoSQL Injectionがありました。\nref : https://weseek.co.jp/ja/news/2021/06/14/growi-nosql-ingection/\nref : JVN#95457785\nCVE-2020-35666 # Software : Steedos Low Code DevOps Platformで見つかったNoSQL Injectionです。\nポストされるパラメータを、X-User-Id[$ne]=1のように書き換える事で、攻撃が実行されます。\nref : https://github.com/steedos/steedos-platform/issues/1245\n診断観点 # SSJIとは # SSJIは、Server Side JavaScript Injectionが正式名称となっています。これは、JavaScript実行の不適切な設定などによって、攻撃者から送信された不正なJavaScriptコードが、サーバサイド側にて実行されてしまう攻撃手法のことです。\nMongo # 以降は脆弱なアプリケーションを利用して、それぞれの攻撃を確認します。\nMongo SSJI # Mongo SSJIについて、DoS攻撃を例に説明します。 MongoDBは、スクリプト言語としてJavaScriptを使うことができます。脆弱なアプリで、$where演算子を利用している箇所に対してtest'; while(1)'を送信します。 すると、無限ループのJavaScriptのコードが実行され、レスポンスが返ってこないことを確認できます。\n否定演算子の挿入 # 否定演算子を挿入について、ログインバイパスを例に説明します。\n正常なリクエストとして、適当な値、{\u0026quot;username\u0026quot;:\u0026quot;admin\u0026quot;,\u0026quot;password\u0026quot;:\u0026quot;admin\u0026quot;}を送信します。適当な値を送信しているので、ログインに失敗していることが確認できます。\n次に、このサイトに対して{\u0026quot;username\u0026quot;:\u0026quot;admin\u0026quot;,\u0026quot;password\u0026quot;:{\u0026quot;$ne\u0026quot;:\u0026quot;\u0026quot;}}を送信します。すると、ログインに成功します。\nMongoDBでは、$neを否定演算子として扱います。この、否定演算子を挿入します。\nPHPなどの言語の仕様である組込みの連想配列処理が悪用され、以下のような配列に変換されます。\narray(\u0026#34;user\u0026#34; =\u0026gt; array(\u0026#34;$ne\u0026#34; =\u0026gt; \u0026#34;admin\u0026#34;), \u0026#34;pass\u0026#34; =\u0026gt; array(\u0026#34;$ne\u0026#34; =\u0026gt; \u0026#34;pass\u0026#34;)); 上記の値が処理されることで、ユーザー名の部分はuser != 'admin'、パスワードの部分はpass != 'pass' となります。よって、指定した値以外のすべてのユーザーにマッチするのでログインできてしまいます。また、指定した値が存在しなかった場合は登録ユーザ全員がマッチします。\nBlind NoSQL Injection # $regex演算子を利用したパスワードの文字数推測を例に説明します。\nまず、ユーザネームがguest,パスワードはpasswordというアカウントがあります。\nここで、{\u0026quot;username\u0026quot;:\u0026quot;guest\u0026quot;,\u0026quot;password\u0026quot;:\u0026quot;password\u0026quot;}を送信すると、ログインに成功します。\n次に、このパスワードの長さを推測するために$regex演算子を用いた、{\u0026quot;username\u0026quot;:\u0026quot;guest\u0026quot;,\u0026quot;password\u0026quot;:{\u0026quot;$regex\u0026quot;:\u0026quot;^.{7}$\u0026quot;}}と、{\u0026quot;username\u0026quot;:\u0026quot;guest\u0026quot;,\u0026quot;password\u0026quot;:{\u0026quot;$regex\u0026quot;:\u0026quot;^.{8}$\u0026quot;}}をそれぞれ送信してみます。\n7文字推測\n8文字推測\nすると、パスワードの長さが8文字と推測したリクエストにてログインが成功していることが分かります。実際にパスワードである文字列passwordは8文字で、パスワードの文字列の長さが推測できます。今回は文字数を推測しましたが、同様に正規表現を用い、文字種を次々と入れレスポンスの差分をみることで、パスワードの文字列そのものを線形探索するといったこともできます。\nRedis # 意図しないデータの挿入 # Nodeでの例を説明します。広く使われているqsモジュールは、クエリ文字列にオブジェクトや配列をパラメータとして渡すことができます。Expressのような一般的なフレームワークでは、このモジュールがデフォルトで有効になっています。このような場合、渡された値によっては、後続のすべてのパラメータを上書きできる可能性があります。その結果、意図しない値がkey-valueペアとして格納されることで、意図しないデータを登録されてしまう事が考えられます。\njsonからの受け取りで挿入 # 以下のようなjsonで値を受け取るコードがあったとします。\napp.use(bodyParser.json());\rapp.post(\u0026#39;/\u0026#39;, function (req, res) { redis.set(req.query.key, \u0026#34;default\u0026#34;);\r}); {key : \u0026quot;foo\u0026quot;}を送信すると、以下が実行されます。\nredis.set(\u0026#34;foo\u0026#34;, \u0026#34;default\u0026#34;); ここで、{key : [\u0026quot;foo\u0026quot;, \u0026quot;evil\u0026quot;]}といったリクエストを送信します。すると、 以下のように実行され、本来入れようとしていた末尾のdefaultが削られてしまいます。\nredis.set([\u0026#34;foo\u0026#34;, \u0026#34;evil\u0026#34;], \u0026#34;default\u0026#34;); クエリ文字列からの挿入 # 以下のようにクエリ文字列で値を受け取るコードがあったとします。\napp.post(\u0026#39;/\u0026#39;, function (req, res) { redis.set(req.query.key, \u0026#34;default\u0026#34;);\r}); ?key=fooを送信すると、以下が実行されます。\nredis.set(\u0026#34;foo\u0026#34;, \u0026#34;default\u0026#34;); ここで、?key[]=foo\u0026amp;key[]=evilといったリクエストを送信します。すると、上記と同様に本来入れようとしていた末尾のdefaultが削られてしまいます。\nredis.set([\u0026#34;foo\u0026#34;, \u0026#34;evil\u0026#34;], \u0026#34;default\u0026#34;); 対策 # MongoDB # 最新バージョンを使用 入力検証・サニタイズライブラリの仕様 mongo-sanitize、mongoose MongoDBにおいては、 where、mapReduce、 group演算子を使用しないようにしましょう。これらの関数は攻撃者が任意のJavaScriptを注入できてしまう可能性があります。また、可能であればmongod.confに以下のように設定しましょう。 javascriptEnabled:false 必要最低限の権限を付与する Redis 意図しないデータの挿入 # 対策として、渡されたパラメータを正しく受け取るように実装しましょう。\n補足資料 # DynamoDB DynamoDB Injection. I have been developing a bunch of… | by Abhay Bhargav | AppSecEngineer | Medium couchdb NOSQL INJECTION memcached The New Page of Injections Book: Memcached Injections A small injection for memcached – HackMag Cassandra br3akp0int: CASSANDRA AND CQL INJECTIONS 参考資料 # NoSQL Injection \u0026gt; Redis NoSQL Injection \u0026gt; Redis. Ever considered injection a problem for… | by Patrick Spiegel | Medium 補助ツール紹介 # NoSQLi Scanner - PortSwigger GitHub - codingo/NoSQLMap: Automated NoSQL database enumeration and web application exploitation tool. GitHub - digininja/nosqlilab: A lab for playing with NoSQL Injection ペイロードリスト NoSQL injection - HackTricks "}]