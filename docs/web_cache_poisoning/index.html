<!doctype html><html lang=ja dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Web Cache Poisoning # Web Cache Poisoning とは、Webサーバとキャッシュ(サーバ) の協調動作の欠陥を利用して、攻撃者が作成した悪意のあるレスポンスをキャッシュに注入する攻撃です。
Webにおけるキャッシュとは、Webサーバとクライアントの間に存在します。キャッシュは再利用可能なレスポンスがキャッシュサーバに存在し、クライアントがそれを要求した場合、Webサーバへリクエストを転送せずにキャッシュサーバからレスポンスをクライアントに転送します。キャッシュサーバの存在によってWebサーバへのリクエスト数を減らすことができ、Webサーバへの負荷を減らすことができる技術です。
影響 # Web Cache Poisoning を利用して攻撃を受けた場合、攻撃者によって作成された悪意のあるコンテンツを被害者が閲覧することになります。悪意のあるコンテンツはフィッシングに悪用されたり、悪意のあるファイルをダウンロードさせたりといったあらゆる攻撃に利用できます。また、悪意のあるコンテンツには以下のようなものを含むことがあり、それらがもたらす影響も同時に受けることを意味します。
クロスサイトスクリプティング(XSS) HTML,CSS, JavaScriptインジェクション オープンリダイレクト など また、被害者のユーザに罠ページ経由で対象サイトにアクセスさせることにより、被害者の機微情報が含まれたページのキャッシュを生成させ、攻撃者がキャッシュを読み取るといった情報漏洩の影響も考えられます。
原因 # キャッシュサーバの動作定義に不備がある場合、Web Cache Poisoning 攻撃に利用される可能性があります。 原因の大まかな例として「不適切なレスポンスをキャッシュしていること」、また「キャッシュを不適切なユーザに配信してしまうこと」等が挙げられます。本来、キャッシュは再利用可能なコンテンツを許可されたユーザに配信するべきものであるため、これらの制御に不備があるとWeb Cache Poisoningに対して脆弱となります。
攻撃手法 # Web Cache Poisoning攻撃を実現するには複数の手順を踏む必要があります。また、その過程で攻撃可能な条件も決定されてきます。
1. キャッシュのための「キーなし入力」を調査する # キャッシュは、コンテンツをユーザに返却するか、あるいはWebサーバにリクエストを転送するかの判断基準としてパスやヘッダなどを参照することがほとんどです。 キャッシュサーバ側では事前に定義されたキーと呼ばれるリクエストの要素を参照します。同じキーが存在した場合はリクエストに対応するコンテンツがキャッシュサーバに存在すると判断され、キャッシュサーバからコンテンツを返却します。
そこで、キーなし入力を見つける必要があります。キーなし入力とはキャッシュサーバが無視するリクエストの要素です。たとえば、User-Agent ヘッダやX-Forwarded-Forヘッダなどはキーなし入力となることが多いです。これらの値が変化してもキャッシュサーバの挙動に変化はありません。キーなし入力を制御することによって、そのほかのキャッシュキーで構成されたリクエストが一致すれば、すべてのユーザに悪意のあるコンテンツを配信できるからです。 キーなし入力の調査をするにはリクエストにさまざまな入力値を付与してその挙動を観察します。ヘッダ部分やリクエストのパスなどに入力を与えて応答がキャッシュされるかを調査します。キャッシュが有効にはたらく入力はキャッシュサーバやWebサーバによって異なるため、しばしば調査にはコストがかかります。多くの場合、ツールなどを用いてほかの脆弱性の調査をする過程でこのキーなし入力の調査をすることが多いです。よく利用されるツールとして、Burp Suiteプラグインである「Param Miner」が挙げられます。このプラグインはリクエストにさまざまなパラメータを付与し、キーなし入力を特定します。
2. 悪意のあるコンテンツを生成させる # Webサイトがそのキーなし入力をどのように処理するのかを検証していきます。たとえば、その入力が適切にエスケープされていない場合はクロスサイトスクリプティングにつながる恐れがあります。パラメータへの検証はその悪意のあるコンテンツの種別によって手法が異なります。 また、機微情報を動的に生成する箇所で再現している場合、キーなし入力を被害者に強制させられるかも検証する必要があります。機密情報を含むキャッシュは被害者によって生成する必要があり、罠ページを経由して送信可能なリクエストの要素(ヘッダやパス、パラメータなど)だけで実現可能であるかが攻撃の成否につながります。
3. レスポンスをキャッシュさせる # 最後に、悪意のあるコンテンツをキャッシュさせます。攻撃者が悪意のあるコンテンツを生成できても、それをキャッシュさせてターゲットとなるほかのユーザに閲覧してもらわなければ攻撃は成立しません。
レスポンスがキャッシュされるかどうかはキャッシュサーバの挙動次第になります。パスに含まれる拡張子やContent-Type、レスポンスヘッダなどさまざまな要素に依存しています。
悪意のあるコンテンツがキャッシュできたら、被害者にそのキャッシュに対してアクセスさせます。キャッシュは一定時間で有効期限が切れ、悪意のあるコンテンツが破棄されます。攻撃者はキャッシュの有効期限が入れても即座に再キャッシュさせるようなスクリプトを定期的に実行することで対応します。
検証方法 # Portswigger Web Security AcademyではWeb Cache Poisoning の検証が可能です。なお、サービス利用には無料ユーザー登録が必要になります。「Web cache poisoning with an unkeyed header」セクションではオーソドックスなWeb Cache Poisoning の検出が体験可能です。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Web Cache Poisoning"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://webapppentestguidelines.github.io/newtechtestdoc/docs/web_cache_poisoning/"><title>Web Cache Poisoning | WebApp Testing</title><link rel=manifest href=/newtechtestdoc/manifest.json><link rel=icon href=/newtechtestdoc/favicon.png type=image/x-icon><link rel=stylesheet href=/newtechtestdoc/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin=anonymous><script defer src=/newtechtestdoc/flexsearch.min.js></script>
<script defer src=/newtechtestdoc/ja.search.min.4d6fcd5493001f119933544bf4d390f829030f6e736fed39da44fa85d1fddc86.js integrity="sha256-TW/NVJMAHxGZM1RL9NOQ+CkDD25zb+052kT6hdH93IY=" crossorigin=anonymous></script>
<script defer src=/newtechtestdoc/sw.min.a87e9a69c1c9637cd6edeaed247d3a7735fae81f6bc6668f69a2cc0a283426ec.js integrity="sha256-qH6aacHJY3zW7ertJH06dzX66B9rxmaPaaLMCig0Juw=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=https://webapppentestguidelines.github.io/newtechtestdoc/docs/web_cache_poisoning/index.xml title="WebApp Testing"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/newtechtestdoc/><span>WebApp Testing</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=検索 aria-label=検索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/newtechtestdoc/docs/oauth/>OAuth/OpenIDConnectの診断手法</a><ul></ul></li><li><a href=/newtechtestdoc/docs/prototype_pollution/>Prototype Pollution</a><ul></ul></li><li><a href=/newtechtestdoc/docs/toctou/>Template</a><ul></ul></li><li><a href=/newtechtestdoc/docs/cloudsec/>クラウドサービスにおけるWebサービスにまつわる脆弱性</a><ul><li><a href=/newtechtestdoc/docs/cloudsec/cloud_credential/>Webアプリケーションの脆弱性を利用した認証情報の窃取</a></li><li><a href=/newtechtestdoc/docs/cloudsec/storage_service/>クラウドストレージサービスにおける設定不備</a></li></ul></li><li><a href=/newtechtestdoc/docs/web_cache_poisoning/ class=active>Web Cache Poisoning</a><ul></ul></li><li><a href=/newtechtestdoc/docs/nosql_injection/nosqli/>Nosqli</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/newtechtestdoc/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Web Cache Poisoning</strong>
<label for=toc-control><img src=/newtechtestdoc/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#影響>影響</a></li><li><a href=#原因>原因</a></li><li><a href=#攻撃手法>攻撃手法</a><ul><li><a href=#1-キャッシュのためのキーなし入力を調査する>1. キャッシュのための「キーなし入力」を調査する</a></li><li><a href=#2-悪意のあるコンテンツを生成させる>2. 悪意のあるコンテンツを生成させる</a></li><li><a href=#3-レスポンスをキャッシュさせる>3. レスポンスをキャッシュさせる</a></li></ul></li><li><a href=#検証方法>検証方法</a><ul><li><a href=#1-キーあり入力を付与>1. キーあり入力を付与</a></li><li><a href=#2-キーなし入力の探索>2. キーなし入力の探索</a></li><li><a href=#利用ツール>利用ツール</a></li></ul></li><li><a href=#事例紹介>事例紹介</a></li><li><a href=#対策>対策</a></li><li><a href=#学習方法参考文献>学習方法/参考文献</a></li></ul></nav></aside></header><article class=markdown><h1 id=web-cache-poisoning>Web Cache Poisoning
<a class=anchor href=#web-cache-poisoning>#</a></h1><p>Web Cache Poisoning とは、Webサーバとキャッシュ(サーバ) の協調動作の欠陥を利用して、攻撃者が作成した悪意のあるレスポンスをキャッシュに注入する攻撃です。<br>　Webにおけるキャッシュとは、Webサーバとクライアントの間に存在します。キャッシュは再利用可能なレスポンスがキャッシュサーバに存在し、クライアントがそれを要求した場合、Webサーバへリクエストを転送せずにキャッシュサーバからレスポンスをクライアントに転送します。キャッシュサーバの存在によってWebサーバへのリクエスト数を減らすことができ、Webサーバへの負荷を減らすことができる技術です。</p><h2 id=影響>影響
<a class=anchor href=#%e5%bd%b1%e9%9f%bf>#</a></h2><p>Web Cache Poisoning を利用して攻撃を受けた場合、攻撃者によって作成された悪意のあるコンテンツを被害者が閲覧することになります。悪意のあるコンテンツはフィッシングに悪用されたり、悪意のあるファイルをダウンロードさせたりといったあらゆる攻撃に利用できます。また、悪意のあるコンテンツには以下のようなものを含むことがあり、それらがもたらす影響も同時に受けることを意味します。</p><ul><li>クロスサイトスクリプティング(XSS)</li><li>HTML,CSS, JavaScriptインジェクション</li><li>オープンリダイレクト など</li></ul><p>また、被害者のユーザに罠ページ経由で対象サイトにアクセスさせることにより、被害者の機微情報が含まれたページのキャッシュを生成させ、攻撃者がキャッシュを読み取るといった情報漏洩の影響も考えられます。</p><h2 id=原因>原因
<a class=anchor href=#%e5%8e%9f%e5%9b%a0>#</a></h2><p>　キャッシュサーバの動作定義に不備がある場合、Web Cache Poisoning 攻撃に利用される可能性があります。
　原因の大まかな例として「不適切なレスポンスをキャッシュしていること」、また「キャッシュを不適切なユーザに配信してしまうこと」等が挙げられます。本来、キャッシュは再利用可能なコンテンツを許可されたユーザに配信するべきものであるため、これらの制御に不備があるとWeb Cache Poisoningに対して脆弱となります。</p><h2 id=攻撃手法>攻撃手法
<a class=anchor href=#%e6%94%bb%e6%92%83%e6%89%8b%e6%b3%95>#</a></h2><p>Web Cache Poisoning攻撃を実現するには複数の手順を踏む必要があります。また、その過程で攻撃可能な条件も決定されてきます。</p><h3 id=1-キャッシュのためのキーなし入力を調査する>1. キャッシュのための「キーなし入力」を調査する
<a class=anchor href=#1-%e3%82%ad%e3%83%a3%e3%83%83%e3%82%b7%e3%83%a5%e3%81%ae%e3%81%9f%e3%82%81%e3%81%ae%e3%82%ad%e3%83%bc%e3%81%aa%e3%81%97%e5%85%a5%e5%8a%9b%e3%82%92%e8%aa%bf%e6%9f%bb%e3%81%99%e3%82%8b>#</a></h3><p>　キャッシュは、コンテンツをユーザに返却するか、あるいはWebサーバにリクエストを転送するかの判断基準としてパスやヘッダなどを参照することがほとんどです。
キャッシュサーバ側では事前に定義されたキーと呼ばれるリクエストの要素を参照します。同じキーが存在した場合はリクエストに対応するコンテンツがキャッシュサーバに存在すると判断され、キャッシュサーバからコンテンツを返却します。<br>　そこで、キーなし入力を見つける必要があります。キーなし入力とはキャッシュサーバが無視するリクエストの要素です。たとえば、User-Agent ヘッダやX-Forwarded-Forヘッダなどはキーなし入力となることが多いです。これらの値が変化してもキャッシュサーバの挙動に変化はありません。キーなし入力を制御することによって、そのほかのキャッシュキーで構成されたリクエストが一致すれば、すべてのユーザに悪意のあるコンテンツを配信できるからです。
　キーなし入力の調査をするにはリクエストにさまざまな入力値を付与してその挙動を観察します。ヘッダ部分やリクエストのパスなどに入力を与えて応答がキャッシュされるかを調査します。キャッシュが有効にはたらく入力はキャッシュサーバやWebサーバによって異なるため、しばしば調査にはコストがかかります。多くの場合、ツールなどを用いてほかの脆弱性の調査をする過程でこのキーなし入力の調査をすることが多いです。よく利用されるツールとして、Burp Suiteプラグインである「Param Miner」が挙げられます。このプラグインはリクエストにさまざまなパラメータを付与し、キーなし入力を特定します。</p><h3 id=2-悪意のあるコンテンツを生成させる>2. 悪意のあるコンテンツを生成させる
<a class=anchor href=#2-%e6%82%aa%e6%84%8f%e3%81%ae%e3%81%82%e3%82%8b%e3%82%b3%e3%83%b3%e3%83%86%e3%83%b3%e3%83%84%e3%82%92%e7%94%9f%e6%88%90%e3%81%95%e3%81%9b%e3%82%8b>#</a></h3><p>　Webサイトがそのキーなし入力をどのように処理するのかを検証していきます。たとえば、その入力が適切にエスケープされていない場合はクロスサイトスクリプティングにつながる恐れがあります。パラメータへの検証はその悪意のあるコンテンツの種別によって手法が異なります。
　また、機微情報を動的に生成する箇所で再現している場合、キーなし入力を被害者に強制させられるかも検証する必要があります。機密情報を含むキャッシュは被害者によって生成する必要があり、罠ページを経由して送信可能なリクエストの要素(ヘッダやパス、パラメータなど)だけで実現可能であるかが攻撃の成否につながります。</p><h3 id=3-レスポンスをキャッシュさせる>3. レスポンスをキャッシュさせる
<a class=anchor href=#3-%e3%83%ac%e3%82%b9%e3%83%9d%e3%83%b3%e3%82%b9%e3%82%92%e3%82%ad%e3%83%a3%e3%83%83%e3%82%b7%e3%83%a5%e3%81%95%e3%81%9b%e3%82%8b>#</a></h3><p>　最後に、悪意のあるコンテンツをキャッシュさせます。攻撃者が悪意のあるコンテンツを生成できても、それをキャッシュさせてターゲットとなるほかのユーザに閲覧してもらわなければ攻撃は成立しません。<br>　レスポンスがキャッシュされるかどうかはキャッシュサーバの挙動次第になります。パスに含まれる拡張子やContent-Type、レスポンスヘッダなどさまざまな要素に依存しています。<br>　悪意のあるコンテンツがキャッシュできたら、被害者にそのキャッシュに対してアクセスさせます。キャッシュは一定時間で有効期限が切れ、悪意のあるコンテンツが破棄されます。攻撃者はキャッシュの有効期限が入れても即座に再キャッシュさせるようなスクリプトを定期的に実行することで対応します。</p><h2 id=検証方法>検証方法
<a class=anchor href=#%e6%a4%9c%e8%a8%bc%e6%96%b9%e6%b3%95>#</a></h2><p>Portswigger Web Security AcademyではWeb Cache Poisoning の検証が可能です。なお、サービス利用には無料ユーザー登録が必要になります。「Web cache poisoning with an unkeyed header」セクションではオーソドックスなWeb Cache Poisoning の検出が体験可能です。</p><h3 id=1-キーあり入力を付与>1. キーあり入力を付与
<a class=anchor href=#1-%e3%82%ad%e3%83%bc%e3%81%82%e3%82%8a%e5%85%a5%e5%8a%9b%e3%82%92%e4%bb%98%e4%b8%8e>#</a></h3><p>適当な商品詳細ページを開いてBurpSuiteのRepeaterへリクエストを登録し、キーあり入力を探索します。ページをキャッシュした際にキャッシュデータを識別するパラメータ要素を付与する必要があるからです。多くの場合、すでに付与されているクエリパラメータをそのまま利用したり、クエリ文字列などにわずかな文字列を付与するだけで十分です。たとえば、以下のようなクエリを与えます。</p><p><code>/product?productId=1&cache=1234</code></p><h3 id=2-キーなし入力の探索>2. キーなし入力の探索
<a class=anchor href=#2-%e3%82%ad%e3%83%bc%e3%81%aa%e3%81%97%e5%85%a5%e5%8a%9b%e3%81%ae%e6%8e%a2%e7%b4%a2>#</a></h3><p>次に、キーなし入力を探索します。攻撃手法のセクションで解説した通り、キャッシュサーバが無視するリクエストの要素を探します。X-Forward-Header や User-Agent などがキーなし入力として利用可能なケースが多いですが、Param Minerを利用してキーなし入力を発見できます。
BurpSuiteのExtenderでParam MinerをBApp Store経由でインストールします。
スキャン対象のリクエストを右クリック→Extensions→ParamMiner→Guess params→Guess headersを選択します。</p><p><img src=./web_cache_poisoning_image1.png alt=image1></p><p>設定は特に変更せずOKを選択してスキャンを開始します。
Extenderタブ→Extensions で、Param Minerを選択して、Outputタブを開きます。
「Queued 1 attacks」と表示され、スキャンが始まります。一定時間経過すると、スキャン結果が表示されます。</p><p><img src=./web_cache_poisoning_image2.png alt=image4></p><p>今回は X-Forwarded-Host や Originヘッダが検出されました。Repeaterに戻って X-Forwarded-Hostヘッダを付与してみます。</p><p><img src=./web_cache_poisoning_image3.png alt=image3></p><p>ヘッダの値がレスポンスに反射しました。さらに、X-Forwarded-Hostを削除して再度リクエストを送信します。</p><p><img src=./web_cache_poisoning_image4.png alt=image4></p><p>ヘッダを付与していないにもかかわらず同じレスポンスが返却されました。
これは、クエリ文字列などに与えたキーをもとにレスポンスがキャッシュされたためです。レスポンスヘッダには「X-Cache: hit」が出力されていることも確認できます。
最後に、キーなしヘッダを自身が管理するサーバや、Portswiggerが提供するexploit serverに置き換えて、不正なJavaScriptを配信できるキャッシュを生成させます。
攻撃者は何らかの方法で同じキーを持つURLを被害者にアクセスさせることで不正なスクリプトを実行できます。</p><h3 id=利用ツール>利用ツール
<a class=anchor href=#%e5%88%a9%e7%94%a8%e3%83%84%e3%83%bc%e3%83%ab>#</a></h3><ul><li><a href=https://github.com/PortSwigger/param-miner>Param Miner</a></li></ul><h2 id=事例紹介>事例紹介
<a class=anchor href=#%e4%ba%8b%e4%be%8b%e7%b4%b9%e4%bb%8b>#</a></h2><ul><li><a href=https://hackerone.com/reports/1424094>https://hackerone.com/reports/1424094</a></li><li><a href=https://hackerone.com/reports/1010858>https://hackerone.com/reports/1010858</a></li></ul><h2 id=対策>対策
<a class=anchor href=#%e5%af%be%e7%ad%96>#</a></h2><p>　最も効果のある対策としては、キャッシュ機能やサーバを無効化することです。すべてWebアプリケーションがコンテンツを都度生成し、配信することでWeb Cache Poisoning の脅威はなくなります。<br>　しかし、本来利便性を上げるための機構であるキャッシュサーバを無効化することは現実的でない場合があります。特に大規模なサイトが多くのリクエストを処理できるのは、キャッシュの存在が大きく貢献しています。この場合は、静的コンテンツにのみキャッシュを適用させ、動的コンテンツはキャッシュさせないようにすることが対策になります。</p><h2 id=学習方法参考文献>学習方法/参考文献
<a class=anchor href=#%e5%ad%a6%e7%bf%92%e6%96%b9%e6%b3%95%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae>#</a></h2><ul><li><a href=https://portswigger.net/Web-security/Web-cache-poisoning/exploiting-design-flaws/lab-Web-cache-poisoning-with-an-unkeyed-header>https://portswigger.net/Web-security/Web-cache-poisoning/exploiting-design-flaws/lab-Web-cache-poisoning-with-an-unkeyed-header</a></li><li><a href=https://portswigger.net/Web-security/Web-cache-poisoning>https://portswigger.net/Web-security/Web-cache-poisoning</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/WebAppPentestGuidelines/newtechtestdoc/commit/17dc78736a82340cf749c96fd132f41847f43a65 title='最終更新者 gorillanet | February 28, 2023' target=_blank rel=noopener><img src=/newtechtestdoc/svg/calendar.svg class=book-icon alt=Calendar>
<span>February 28, 2023</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#影響>影響</a></li><li><a href=#原因>原因</a></li><li><a href=#攻撃手法>攻撃手法</a><ul><li><a href=#1-キャッシュのためのキーなし入力を調査する>1. キャッシュのための「キーなし入力」を調査する</a></li><li><a href=#2-悪意のあるコンテンツを生成させる>2. 悪意のあるコンテンツを生成させる</a></li><li><a href=#3-レスポンスをキャッシュさせる>3. レスポンスをキャッシュさせる</a></li></ul></li><li><a href=#検証方法>検証方法</a><ul><li><a href=#1-キーあり入力を付与>1. キーあり入力を付与</a></li><li><a href=#2-キーなし入力の探索>2. キーなし入力の探索</a></li><li><a href=#利用ツール>利用ツール</a></li></ul></li><li><a href=#事例紹介>事例紹介</a></li><li><a href=#対策>対策</a></li><li><a href=#学習方法参考文献>学習方法/参考文献</a></li></ul></nav></div></aside></main></body></html>