[{"id":0,"href":"/oauth/","title":"OAuth/OpenIDConnectの診断手法","section":"Introduction","content":" OAuth/OpenIDConnectの診断手法 # 概要 # 本章では、OAuth2.0およびOpenIDConnectと、それに関連するしくみについての脆弱性や攻撃手法について説明します。 なお、本ドキュメントに記載する用語、パラメータ名などはRFC 6749およびOpenID Connect Core 1.0 incorporating errata set 1の記載に準拠します。\nOAtuh2.0 # OAuth2.0は、リソースサーバや認可サーバから見てサードパーティとなるクライアントサーバやアプリケーション等が、その認可に応じてリソースサーバに保存されているリソースオーナの情報を得るための認可フレームワークです。 通常のアプリケーションのようにクライアント/サーバだけではなく、認可サーバ/リソースサーバを含めた三者間の関係でセキュリティを考慮する必要があります。そのため、各パラメータの目的を考えながら、仕様通り正しく実装する必要があります。\n以下では代表的な脆弱性の概要や診断手法について記載します。\nオープンリダイレクタ # 概要 # 認可サーバでの認可が完了すると、リソースオーナのブラウザはredirect_uriパラメータで指定されたURLへリダイレクトされます。このリダイレクト時にオープンリダイレクタの脆弱性が存在すると、リソースオーナのブラウザが攻撃者の管理するサーバへリダイレクトされ、認可コード／アクセストークンが漏えいします。\n原因と影響 # Authorization Code Grantを利用しているネイティブアプリケーションがPKCEを利用していない、もしくは認可サーバがPKCEに対応していないことが原因です。 この攻撃によって認可コードが漏えいした場合、正規のアプリケーションになりすまして不正にアクセストークンを発行される可能性があります。\n診断観点 # 診断時においては、ネイティブアプリケーションからのOAuthのフロー開始後、PKCE関連のパラメータが送信されているか、送信されている場合にその値が適切に検証されているかを検査する必要があります。\n認可リクエストにおいては、code_challengeおよびcode_challenge_methodパラメータが送信されているかを確認します。もし送信されている場合には、いずれか一方の値を適当な値に改ざんしてもフローが正常に完了するか検査します。\nトークンリクエストにおいては、code_verifierを含めないもしくは正規のcode_verifier以外の値に改ざんしてもフローが正常に完了するか検査します。\n対策 # 認可コード横取り攻撃は認可サーバでの対策が必要です。 RFC 7636で策定されたPKCE(Proof Key for Code Exchange)に準拠した実装をします。また、自身を利用するクライアントに対して、PKCEに準拠した各パラメータの送信を必須として要求します。\nクロスサイトリクエストフォージェリ # 概要 # OAuth2.0におけるstateパラメータは、端的にはCSRF攻撃を防ぐためのパラメータです。 本パラメータに着眼して認可コードフローを見ると、以下のようになります。\nクライアントサーバは、stateとしてランダムな値を発行し、リソースオーナーのブラウザのセッションと紐づけて保存する ブラウザは、クライアントサーバから発行されたstateを含む認可サーバへのURLへアクセスする 認可サーバは、codeパラメータとともに(2)のリダイレクト時に受け取ったstateをURLに付与してブラウザをクライアントサーバへリダイレクトさせる クライアントサーバは、ブラウザからcodeとstateを受け取り、(1)で保存したstateと一致している場合は以降の処理を実施する このフローにおいてstateパラメータの検証を適切に行っていない場合、以下の手順で攻撃が可能となります。\n攻撃者は、上記フローにのっとって発行された自身のcodeを用いて、そのcodeを付与して被害者ブラウザをクライアントサーバへリダイレクトさせるような罠サイトを作る 罠サイトにアクセスした被害者のセッションと攻撃者のcodeの組をクライアントサーバで処理される 被害者は、攻撃者のアカウントでログインした状態となる 原因と影響 # 前述の通り、原因は、クライアントサーバが、codeパラメータを受け取る際に、stateパラメータを検証していないことです。 これによって、攻撃者のアカウント向けに発行されたcodeパラメータを、被害者に強制させることができます。\nこの影響はサイトや機能によって異なります。 たとえば、会員登録後に他サイトのアカウントと連携設定することで当該サイトのアカウントで会員としてログインできる機能をもったサイトの場合を考えます。この場合、連携設定の際に攻撃者アカウントのcodeを被害者のセッションに強制することで、攻撃者アカウントで当該サイトに被害者としてログインできます。\n診断観点 # 診断時においては、CSRFの観点からstateパラメータを検証する必要があります。\nOAuthはその性質上セッションを維持したまま外部サイトからのGET等を受け付ける必要があります。このため、Samesite属性によってCSRFを防いでいるサイトであっても、CSRF可能となる場合があるので、注意が必要です。\n対策 # 対策は、処理前に十分にランダムなstateを付与し、codeパラメータを処理する前にセッションから読み出したstateとリダイレクトによって送られてきたstateが同一であるかを検証することです。\nクライアント認証の不備 # 概要 # アクセストークンリクエストは、アクセストークン取得のためにクライアントから認可サーバ宛に送信されるリクエストです。アクセストークンリクエスト時にはクライアント認証が必須とされており、ここでの認証に不備があると、正規のクライアントになりすましてアクセストークンを発行可能となります。\n原因と影響 # 認可サーバが、アクセストークンリクエスト受信時にクライアントへ認証を要求していないことが原因です。 このような場合、何らかの手段で漏えいした認可コードを用いて、正規のクライアントになりすましたアクセストークンを発行される可能性があります。\n診断観点 # 認可サーバから得たアクセストークンをサーバに送信していたり、そのアクセストークンによって解決した情報をサーバに送信している場合は注意が必要です。その値が改ざん可能であることを留意した設計になっているか検証する必要があります。\n対策 # アクセストークンリクエスト送信時に、クライアントへ認証を要求します。ここでの認証方式は厳密に指定されておらず、パスワード認証やクライアント証明書などが利用可能です。\nImplicit Grant Flowをサーバと関係した処理で用いる # 概要 # Implicitフローは認可サーバとリソースオーナーのユーザエージェントのみで構成されるアプリケーションにおいて使える機能です。このフローで得た情報をサーバに送信する場合、当該値はリソースオーナーによって改ざん可能であるため、信頼できない値として扱う必要があります。\n原因と影響 # たとえばImplicitフローで得られたリソースオーナーの住所をサーバに送信して、リソースサーバから連携された身元情報として取り扱う場合を考えます。この場合攻撃者は、リソースサーバから得られた住所を改変して送信することで、リソースサーバによって検証されていない値を登録できます。\nまた、クライアントがアクセストークンをリソースオーナーのユーザエージェントから直接受け取っている場合、リソースオーナーは任意のアクセストークンを送信できます。よって当該クライアント向けに発行されたものであるか検証しない限り、攻撃者サーバを利用したユーザのアクセストークンを使って、対象サイト上の機能を悪用できる可能性があります。\n対策 # 認可サーバとリソースオーナのユーザエージェント以外が関与する場合はImplicitフローではなく、認可コードフローを用いてください。\nOpenID Connect # OpenIDConnectにおいても、その一部はOAuth2.0と同様の処理であるため、その共通する処理に関しては前述の問題が起こり得ます。 ただし、OpenID Connect特有の問題もあります。以下ではその問題について解説します。\nIDTokenの検証不備 # 概要 # OpenIDConnectにおいては、最終的にユーザのアイデンティティを証明するものとして、JsonWebTokenが発行されます。このトークンには発行元や発行先、有効期限などが保持されており、署名によって正当性を検証できるようになっています。 正当性検証を怠った場合、JWT改ざんによって、なりすまし等の被害を発生させる恐れがあります。\n原因と影響 # トークンの署名検証に不備がある場合、攻撃者はトークンを改ざんできるため、JWT内のパラメータを改ざんすることで、なりすますことが可能です。alg:Noneを指定できる場合や、攻撃者にとって既知の鍵を用いている場合などが不備の典型例です。\n診断観点 # alg none # 署名検証不備を狙う攻撃として著名なものにJWTヘッダのalgの値にnoneを設定し、署名検証を回避させるものがあります。IDトークンの検証者がnoneの設定を許容している場合、IDトークンに含まれるclaimの値を攻撃者が自由に改ざん可能となり、第三者へのなりすましが容易に可能となります。\nalg hs256 # noneがIdPによって拒否された場合、別のアルゴリズムを指定することで署名検証の不備を突破できる可能性があります。それはHS256です。改ざん対象のIDトークンの署名に用いられた秘密鍵と対になるIdPの公開鍵を特定し、その公開鍵を用いてIDトークンの署名を生成します。この時のIDトークンは、ヘッダのalgの値としてHS256を指定した新たなIDトークンとして生成します。署名に用いたIdPの公開鍵をkidパラメータなどで指定できる場合、IDトークンに含まれるclaimの値を攻撃者が自由に改ざん可能となり、第三者へのなりすましが容易に可能となります。\n対策 # まず署名検証を正しく行う必要があります。自身がRPの場合、署名検証アルゴリズムは独自に実装せず、ライブラリ等を用いて検証しましょう。自身がidpを担う場合は、ライブラリ使用に加え、JWT署名専用の鍵を生成・保管し鍵を使いまわさないようにしてください。 加えて、自身がRPの場合は利用しているidpが各クレームをどのように用いているか念のため確認することを推奨します。idpが推奨する利用法や実装に沿って認証機能を実装しましょう。自身がidpの場合は、仕様に沿って各クレームを実装してください。仕様書にないクレームを付与する場合は、その意味や想定される使い方を公開してください。\nリプレイアタック # 概要 # リプレイアタックとは、すでにRPで利用されたIDトークンを再送することで、正規のユーザになりすましてRPへログインすることを試みる攻撃です。 すでに利用済みのIDトークンを利用することから、正規のOIDCフローが完了した後に懸念されます。\n原因と影響 # リプレイアタックが発生する原因にはRPとOPそれぞれの実装不備が関与します。\nRP # ユーザのセッションと紐づくnonceパラメータを認証リクエストに含めていない、もしくはトークンレスポンス受信時にnonceパラメータを削除していない、のいずれか一方でも満たしていないことが原因です。\nOP # IDトークンのclaimに、認証リクエストで受け取ったnonceパラメータを含めていないことが原因です。 これによって、何らかの手段でIDトークンを入手した攻撃者によって、正規のユーザになりすましてRPへログインされる可能性があります。\n診断観点 # 診断時においては、IDトークンの再送が可能であるかを検査します。 手順として、まず一度OIDCのフローを完了してIDトークンを発行します。その後、別のユーザとしてOIDCのフローをあらためて開始し、トークンレスポンス内のIDトークンを、最初に発行したIDトークンへ置き換えます。その結果、最初にIDトークンを発行したユーザとしてRPへログインに成功する場合、リプレイアタックが可能となります。\n対策 # RPとOPのそれぞれで対策が必要です。\nRP # 以下3点のどちらの対応も必須です。\nユーザのセッションに紐づく値を生成し、認証リクエストにnonceパラメータとして含める IDトークンのclaim内のnonceパラメータとユーザのセッションに紐づく値が一致することを検証する 検証後にセッションからnonceに一致する値を削除する OP # 認証リクエストにnonceパラメータが含まれている場合は、発行するIDトークンのclaimにそのnonceパラメータをそのまま含める。\n"},{"id":1,"href":"/prototype_pollution/","title":"Prototype Pollution","section":"Introduction","content":" Prototype Pollution # 概要 # Prototype Pollution は、JavaScript において主に\u0026quot;継承\u0026quot;を実現するために用いられる、__proto__プロパティを通じて特定のオブジェクトの内容を不正に変更する攻撃手法またはそれに対する脆弱性です。\n影響 # Prototype Pollution の影響は様々で、発生箇所やアプリケーションのロジックに依存します。 最悪の場合ではサーバサイドでの任意コード実行に繋がることがあり、その他の場合では XSS や SQL インジェクションなどの脆弱性にも繋がる可能性があります。\n原因 # 攻撃者が__proto__プロパティなどを経由して、特定のオブジェクトの prototype を操作可能であることが Prototype Pollution の原因です。\n攻撃手法 # 実際にオブジェクトの__proto__プロパティが操作可能なケースとして、下記 2 つの例を紹介します。\nオブジェクトに対して merge や clone の操作を行うケース setValue(obj, key, value)のようにオブジェクトのプロパティを設定するケース 1. オブジェクトに対して merge や clone の操作を行うケース # 以下のmerge(tgt, src)は、引数のtgtオブジェクトにsrcのプロパティを再帰的にマージします。 この実装では与えられたオブジェクトのkeyの値をチェックしておらず、任意のkeyに対して任意の値を代入できます。(10 行目)\nfunction isObject(obj) { return obj !== null \u0026amp;\u0026amp; typeof obj === \u0026#39;object\u0026#39;; } function merge(tgt, src) { for (let key in src) { if (isObject(tgt[key]) \u0026amp;\u0026amp; isObject(src[key])) { merge(tgt[key], src[key]); } else { tgt[key] = src[key]; } } return tgt; } merge( {a: 1, b: 2}, JSON.parse(\u0026#39;{\u0026#34;__proto__\u0026#34;: {\u0026#34;polluted\u0026#34;: 1}}\u0026#39;) ); const obj = {}; console.log(obj.polluted); // =\u0026gt; 1 上記の PoC では、引数srcに{\u0026quot;__proto__\u0026quot;: {\u0026quot;polluted\u0026quot;: 1}}というオブジェクトを渡しており、10 行目でtgt[__proto__] = {\u0026quot;polluted\u0026quot;:1}のような代入が実行されることで攻撃が成功しています。\n2. setValue(obj, key, value)のようにオブジェクトのプロパティを設定するケース # 以下のsetValue(obj, key, value)は、引数のobjオブジェクトに{key:value}のプロパティを追加します。また、keyにチェーン演算子を用いて指定することで深くに位置するプロパティを追加します。\nこの実装でも引数keyの値をチェックしておらず、任意のkeyに対して任意の値を代入できます。(13 行目)\nfunction isObject(obj) { return obj !== null \u0026amp;\u0026amp; typeof obj === \u0026#39;object\u0026#39;; } function setValue(obj, key, value) { const keylist = key.split(\u0026#39;.\u0026#39;); const e = keylist.shift(); if (keylist.length \u0026gt; 0) { if (!isObject(obj[e])) obj[e] = {}; setValue(obj[e], keylist.join(\u0026#39;.\u0026#39;), value); } else { obj[key] = value; return obj; }} setValue({}, \u0026#34;__proto__.polluted\u0026#34;, 1); const a = \u0026#34;\u0026#34;; console.log(a.polluted); // =\u0026gt; 1 上記の PoC では、引数keyに__proto__.pollutedという値を渡しており、再帰的に処理されることで結果的に 13 行目でobj[__proto__][polluted] = 1のような代入が実行されることで攻撃が成功しています。\n事例紹介 # NVD - cve-2019-7609 #1106238 Stored XSS via Mermaid Prototype Pollution vulnerability #454365 Prototype pollution attack through jQuery $.extend 対策 # Prototype Pollution の対策にはいくつか方法があるため、アプリケーションの規模や副作用を考慮して、適当な対策を選択するようにしてください。 ここでは代表的な下記 5 つの方法を紹介します。\nライブラリを利用する方法 Object.freezeを使用する方法 Objectの代わりにMapを使う方法 オブジェクトの作成をObject.create(null)で行う方法 Schema validation of JSON input ライブラリを利用する方法 # 要件を満たす場合、Prototype Pollution の影響を受けずにオブジェクトに対して merge や clone を行うライブラリを利用することで防ぐことができます。\nObject.freezeを使用する方法 # Object.freeze()を使用して、Object や Object.prototype を変更できないようにすることで、prototype が意図せず汚染されないようにできます。\n下記のコードは、実際にObject.freeze()を使用して実際に対策できることを示す PoC です。\nObject.freeze(Object.prototype); Object.freeze(Object); ({}.__proto__.test = 123); console.log({}.test); // =\u0026gt; undefined なお、注意点として、（上記の PoC を実際に動かしてみてもわかる通り、）Object.freeze()によって freeze されたオブジェクトの変更は、特にエラーや例外が起こることなく失敗します。 そのため、本対策を適用し意図しない副作用が発生した場合でも、その副作用を発見するのが困難な場合があります。 したがって、この対策は（依存ライブラリを含めた）アプリケーションの現状の実装を考慮して、慎重に適用することを推奨します。\nObjectの代わりにMapを使う方法 # ES6 以降では、Objectの代わりにMapが利用できます。 Objectを単純に key/value のデータ構造を利用している場合は、それらをMapに置き換えることで、Prototype Pollution を防ぐことができます。\nオブジェクトの作成をObject.create(null)で行う方法 # Object.create()にnullを渡す方法で、prototype を引き継がないオブジェクトを作成することで、__proto__経由で prototype が汚染されることを防ぐことができます。 下記のようなコードで、実際に__proto__経由で prototype にアクセスできないことを実際に確認できます。\nvar obj = Object.create(null); console.log(obj.__proto__ === Object.prototype); // =\u0026gt; false console.log(obj.__proto__); // =\u0026gt; undefined もし{\u0026quot;a\u0026quot;: 1, \u0026quot;b\u0026quot;: 2}のような元々いくつかのプロパティを持つオブジェクトを作成する場合は、下記のようにObject.assign()を併せて利用する必要があります。\nvar obj = Object.assign(Object.create(null), { a: 1, b: 2 }); なお、このように作成されたオブジェクトの prototype はObject.prototypeの参照ではないため、hasOwnProperty()のようなObject.prototypeのメソッドはプロトタイプチェーン経由で呼び出せません。 もし、そのようなメソッドを呼び出したい場合はObject.prototype.hasOwnPropertyのように明示的に行う必要があります。\nvar obj = Object.create(null); obj.a = 1; Object.prototype.hasOwnProperty.call(obj, \u0026#34;a\u0026#34;); // =\u0026gt; true Object.create(null)による本対策を適用する場合は、このような副作用に留意してください。\nSchema validation of JSON input # JSON SchemaではadditionalProperties:falseを指定することで、想定していないプロパティを禁止することができます。 適切な JSON Scheme を用いてバリデーションを行うことで Prototype Pollution の対策ができます。\n以下は、前述の関数setValue()に対し、ajvを用いて対策を行う例です。\nconst schema = { type: \u0026#34;object\u0026#34;, properties: { // 想定しているプロパティ }, additionalProperties: false, }; const validate = ajv.compile(schema); function setValue(obj, key, value) { const keylist = key.split(\u0026#34;.\u0026#34;); const e = keylist.shift(); if (keylist.length \u0026gt; 0) { if (!isObject(obj[e])) obj[e] = {}; setValue(obj[e], keylist.join(\u0026#34;.\u0026#34;), value); } else { obj[key] = value; if (!validate(obj)) { // handling throw \u0026#34;Invalid Obj\u0026#34;; } return obj; } } setValue({}, \u0026#34;__proto__.polluted\u0026#34;, 1); // =\u0026gt; Exception raised ただし、この場合、propertiesに含んでいないプロパティは一切追加ができなくなることに注意が必要です。 任意のプロパティを受け入れつつ対策をする場合、単に追加される key に悪意のある値が指定されないように制限する対策も有効です。\nfunction setValue(obj, key, value) { const keylist = key.split(\u0026#34;.\u0026#34;); const e = keylist.shift(); if (keylist.length \u0026gt; 0) { if (!isObject(obj[e])) obj[e] = {}; if (e !== \u0026#34;__proto__\u0026#34; \u0026amp;\u0026amp; e !== \u0026#34;constructor\u0026#34;) { setValue(obj[e], keylist.join(\u0026#34;.\u0026#34;), value); } } else { obj[key] = value; return obj; } } setValue({}, \u0026#34;__proto__.polluted\u0026#34;, 1); const a = \u0026#34;\u0026#34;; console.log(a.polluted); // =\u0026gt; undefined 診断方法 # 基本的な診断方法 # これまでに説明した Prototype Pollution の基本原理や攻撃手法などを踏まえ、任意のオブジェクトの prototype が不正に変更できないかを検証してください。\nDOM Invader を用いた効率的な診断 # DOM Invader は Burp の機能で DOM XSS のテストやpostMessage()の操作を用いたテストの支援を提供します。この機能を用いることでクライアントサイドの Prototype Pollution の自動検出や手動での検証の補助として利用可能です。\n詳しい検証方法はTesting for client-side prototype pollutionで丁寧に解説されているので、こちらを参照してください。\n学習方法/参考文献 # HoLyVieR/prototype-pollution-nsec18: Content released at NorthSec 2018 for my talk on prototype pollution Olivier Arteau \u0026ndash; Prototype pollution attacks in NodeJS applications - YouTube Node.js における prototype 汚染攻撃への対策 - SST エンジニアブログ 【1 分見て】実例から学ぶ prototype pollution【kurenaif 勉強日記】 - YouTube Prototype pollution: The dangerous and underrated vulnerability impacting JavaScript applications | The Daily Swig BlackFan/client-side-prototype-pollution: Prototype Pollution and useful Script Gadgets Object.prototype.proto - JavaScript | MDN "},{"id":2,"href":"/toctou/","title":"Template","section":"Introduction","content":" TOCTOU/レースコンディション # 概要 # システム開発のセキュリティにおいてレースコンディションとTOCTOUは、しばしば混同して使われることがありますが、それぞれの違いについて用語の整理から確認していきましょう。\nレースコンディション(race condition)とは、複数の処理が同じデータに対して同時にアクセスしたときに競合状態になることで、想定外の処理が引き起こされる問題です。\n対してTime Of Check To Time Of Use(TOCTOU)とは、あるデータを使用する際に、データの状態をチェックする処理から実際にそのデータを使用する処理するまでの間に、データの状態が変化してしまうことで想定外の処理が引き起こされる問題です。\n要約すると、レースコンディションは様々な競合状態の問題を表す包括的な脆弱性なのに対し、TOCTOUはより実装の状況を限定した具体的な脆弱性であることが分かります。\n本章では、主にTOCTOUに関連する脆弱性や攻撃手法について説明します。\n原因 # TOCTOUは主にデータのチェックとそのデータの使用するタイミングが異なっていることに起因しています。 そのため、TOCTOUを対策する考え方としては、データのチェックと使用を同時に行い、処理の差を発生させないようにすることが理想的です。\n影響 # 代表的な脅威の例として、許可されていないデータへのアクセスや、回数制限などを超えて実行することを許してしまうような影響が考えられますが、データの内容や重要性、アプリケーションの振る舞いなどのビジネスロジックによってTOCTOUによる影響範囲は大きく異なります。\nここでは、TOCTOUが発生しやすい機能を例にあげます。\n送金処理 クーポンやキャンペーンコード等の発行や使用 アカウントの新規登録 高評価、いいねボタンなどの投票機能 診断観点/攻撃手法 # 一般的に、DASTのようなツールを使用してTOCTOUの脆弱性を特定することは困難です。\nこれは、競合状態を引き起こした状態と正常なWebアプリケーションの振る舞いの違いを機械的に判断することは難しいためです。\nまた、TOCTOUの検査を行うためにはミリ秒単位で調整されたリクエスト送信や単一のHTTPパイプライン内で複数のHTTPリクエストを送る検査が必要になってくるため、Webアプリケーション診断に特化した専門ツール(Burpなど)が必要になるでしょう。\nこのように、競合状態を起こすための条件や環境を整える必要がある性質上、手動によるテストも他のWebアプリケーション脆弱性検査に比べて検査が難しいと考えられています。\nTOCTOUの脆弱性を見つけるためには、データのチェック処理とデータを使用する処理が別のタイミングで行われている箇所を探しましょう。\n具体的には、実行回数に制限があるような機能や重複防止の制限が設けられている機能などでTOCTOUの検査を行うことが有用です。\nBurp Intruderを使用した検査 # Burp Intruderを使用してTOCTOUの検査を確認するパターンを紹介します。Burp IntruderはBurpに搭載されている機能の一つですが、Community Editionには機能制限があるためPro Editionでしか検査が行えません。Community Editionを使用する場合は、後述するTurbo Intruderを使用した検査方法をご覧ください。\nはじめに、送信したいリクエストをBurp Intruderにセットします。\nBurp Intruderを開始するにはペイロードポジションを設定する必要がありますが、ペイロードによる作用を防ぐため、ここではダミー用のリクエストヘッダー(x-dummy)を用意し、ダミー用ヘッダーの値にペイロードポジションを設定します。\n次に、ペイロードの設定を行います。\nPayload TypeをNull payloadsに設定します。\nGenerateの空白欄に送信したいリクエスト数を入力します。\nデフォルトでは同時に10リクエストを送信します。\nより多くのリクエストを送信したい場合は、Resource Pool設定から新しいリソースプール設定を作成し、Maximum concurrent requestsを設定してください。\nTurbo Intruderを使用した検査 # Burp Suiteの拡張機能として公開されているTrubo Intruderを使用したパターンを紹介します。\nTurbo Intruderは、大量のHTTPリクエストを送信したり、Pythonを使用して柔軟にリクエスト前後の処理を操作することができる拡張機能です。\nまた、Turbo Intruderは、標準のBurp Intruderとは異なりCommunity Editionでも使用することが可能です。\n注意\nTurbo Intruderは、Port Swigger社のセキュリティリサーチャーであるJames Kettle氏によって開発されていますが、十分なテストが行われていないためBurpの標準機能よりも信頼性がなく、システムパフォーマンスに影響を及ぼす可能性があるため、拡張機能を使用される際には自己責任でお願い致します。 送信したいリクエストを選択し、コンテキストメニューからExtensions-\u0026gt;Turbo Intruder-\u0026gt;Send to turbo intruderをクリックして、Turbo Intruderへリクエストを送ります。\n別のウィンドウが表示されます。\nTurbo IntruderもBurp Intruderと同様にペイロードポジションを設定する必要があります。ここではダミー用のリクエストヘッダー(x-dummy)を用意し、ダミー用ヘッダーの値に%sをセットしてペイロードポジションを設定します。\n次にドロップダウンリストから「examples/race.py」を選択します。\nデフォルトでは同時に30リクエスト送信する設定になっています。例として10リクエスト送信したい場合は、9行目のrange関数の引数を修正します。\n事例紹介 # https://github.com/reddelexc/hackerone-reports/blob/master/tops_by_bug_type/TOPRACECONDITION.md 対策 # データの整合性を保つ設計を行う必要があります。しかしながら、Webアプリケーション毎によって実装やデザインが異なるため、具体的な方法は多岐に分かれます。\n考えられる対策として、データのチェックからデータ更新までの一連の処理が完了するまで、他のスレッドやプロセスからアクセスできないようにしてください。\nデータベースで管理している場合はトランザクションを行い、読み書きする情報にロックを掛ける実装にしてください。\nただし、ロックの範囲が広すぎると脆弱性発生箇所とは異なる箇所でデッドロックが発生したり、トランザクション処理によってパフォーマンスにも影響を及ぼす可能性があるため注意してください。\n学習方法/参考文献 # https://timegaptheory.com/index.html "},{"id":3,"href":"/cloudsec/","title":"クラウドサービスにおけるWebサービスにまつわる脆弱性","section":"Introduction","content":" クラウドサービスにおけるWebサービスにまつわる脆弱性 # 近年では、クラウドサービスを活用し、Webサービスを構築・提供しているという事例はもはや一般的となりました。 クラウドサービスでは、クラウド事業者側がセキュリティを担保してくれるため、利用者側は特にセキュリティを意識しなくても良いと思われるかもしれませんが、残念ながらそうではありません。\nクラウドサービスにおいては、「責任共有モデル」という考え方が存在します。 「責任共有モデル」とは利用者側・クラウド事業者側の間で、それぞれがサービス提供における担当範囲を明確にし、運用上の責任を共有するという考え方です。\nAWSの責任共有モデル\nhttps://aws.amazon.com/jp/compliance/shared-responsibility-model/ 一般的な例でいえば、IaaS(Infrastructure as a Service)においてはクラウド事業者が提供するのはインフラだけとなり、IaaSの上に構築されるOSやミドルウェア、アプリケーション、データ等に関しては、利用者側が責任を持たなければなりません。 一方PaaS(Platform as a Service)であれば、インフラ・OS・ミドルウェアはクラウド事業者が提供しますが、アプリケーション、データに関しては利用者側が責任を持たなければなりません。 上記のように、利用者とクラウド事業者の間で責任分担の境界線がしっかりと引かれており、利用者が責任を持つべき箇所が明確となっています。 これらの責任分界点については、クラウド事業者や提供するサービスによってそれぞれ定義が異なります。 なお、Cloud Security Alliance(CSA)からはコンテナやサーバーレスアーキテクチャなどの比較的新しいサービス領域についてさらに細分化した責任共有モデルなども公開されています。\nThe Evolution of Cloud Computing and the Updated Shared Responsibility\nhttps://cloudsecurityalliance.org/blog/2021/02/04/the-evolution-of-cloud-computing-and-the-updated-shared-responsibility/ 利用者側が責任を持たなければならない範囲において、誤った実装や設定上のミスなどが存在した場合には、セキュリティ上の問題となってしまう可能性があります。 現実世界でも上記が起因となって発生したセキュリティインシデントが多数報告されています。 そのため、利用者側はこういった良くありがちなセキュリティ上の問題について理解し、正しい実装・設定や問題の発生を防止するための施策を行う必要があるでしょう。\nここでは、「クラウドサービスを利用して構築しているWebサービスにおける誤った実装・設定不備などを起因としたセキュリティ上の問題点」について、近年話題となっている代表的ないくつかの事例を紹介しています。\nクラウドストレージサービスにおける設定不備 Webアプリケーションの脆弱性を利用したクラウドクレデンシャルの奪取 FaaSにおける設定不備と脆弱性の悪用 IDaaSの活用に起因する脆弱性とその悪用 "}]