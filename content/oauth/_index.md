---
title: OAuth/OpenIDConnectの診断手法
weight: 999

---

# OAuth/OpenIDConnectの診断手法
## 概要
この章では、OAuth2.0およびOpenIDConnectと、それに関連する仕組みについての脆弱性や攻撃手法について説明します。
なお、本ドキュメントに記載する用語、パラメータ名などはRFC6749およびOpenID Connect Core 1.0 incorporating errata set 1の記載に準拠します。

# OAtuh2.0
OAuth2.0は、リソースサーバや認可サーバから見てサードパーティとなる、クライアントサーバやアプリケーション等が、その認可に応じてリソースサーバに保存されているリソースオーナの情報を得るための、認可フレームワークです。
通常のアプリケーションのようにクライアント・サーバだけではなく、認可サーバ/リソースサーバを含めた三者間の関係でセキュリティを考慮する必要があります。そのため、各パラメータの目的を考えながら、仕様通り正しく実装する必要があります。

以下では代表的な脆弱性の概要や診断手法について記載します。

## オープンリダイレクタ
### 概要
認可サーバでの認可が完了すると、リソースオーナのブラウザはredirect_uriパラメータで指定されたURLへリダイレクトされます。このリダイレクト時にオープンリダイレクタの脆弱性が存在すると、リソースオーナのブラウザが攻撃者の管理するサーバへリダイレクトされ、認可コード／アクセストークンが漏えいします。

### 原因と影響
Authorization Code Grantを利用しているネイティブアプリがPKCEを利用していない、もしくは認可サーバがPKCEに対応していないことが原因です。
この攻撃によって認可コードが漏えいした場合、正規のアプリになりすまして不正にアクセストークンを発行される可能性があります。

### 診断観点
診断時においては、ネイティブアプリからのOAuthのフロー開始後、PKCE関連のパラメータが送信されているか、送信されている場合にその値が適切に検証されているかを検査する必要があります。

認可リクエストにおいては、code_challengeおよびcode_challenge_methodパラメータが送信されているかを確認し、送信されている場合にはいずれか一方の値を適当な値に改ざんしてもフローが正常に完了するか検査します。

トークンリクエストにおいては、code_verifierを含めないもしくは正規のcode_verifier以外の値に改ざんしてもフローが正常に完了するか検査します。

### 対策
認可コード横取り攻撃は認可サーバでの対策が必要です。
RFC7636で策定されたPKCE(Proof Key for Code Exchange)に準拠した実装を行います。また、自身を利用するクライアントに対して、PKCEに準拠した各パラメータの送信を必須として要求します。

## クロスサイトリクエストフォージェリ
### 概要
OAuth2.0におけるstateパラメータは、端的にはCSRF攻撃を防ぐためのパラメータです。
本パラメータに着眼して認可コードフローを見ると、以下のようになります。

1. クライアントサーバは、stateとしてランダムな値を発行し、リソースオーナーのブラウザのセッションと紐づけて保存する
1. ブラウザは、クライアントサーバから発行されたstateを含む認可サーバへのURLへアクセスする
1. 認可サーバは、codeパラメータと共に(2)のリダイレクト時に受け取ったstateをURLに付与してブラウザをクライアントサーバへリダイレクトさせる
1. クライアントサーバは、ブラウザからcodeとstateを受け取り、(1)で保存したstateと一致している場合は以降の処理を実施する

このフローにおいてstateパラメータの検証を適切に行っていない場合、攻撃者のcodeを付与して被害者ブラウザをクライアントサーバへリダイレクトさせるような罠サイトを作ることで、その罠サイトにアクセスした被害者のセッションと攻撃者のcodeの組をクライアントサーバで処理させることが出来ます。

### 原因と影響
前述の通り、原因は、クライアントサーバが、codeパラメータを受け取る際に、stateパラメータを検証していないことです。
これによって、攻撃者のアカウント向けに発行されたcodeパラメータを、被害者に強制させることができます。

この影響はサイトや機能によって異なります。
例えば、会員登録後に他サイトのアカウントと連携設定することで当該サイトのアカウントで会員としてログインできる機能をもったサイトの場合、連携設定の際に攻撃者アカウントのcodeを被害者のセッションに強制することで、攻撃者アカウントで当該サイトに被害者としてログインできるようになります。

### 診断観点
診断時においては、CSRFの観点からstateパラメータを検証する必要があります。
特にSamesite属性によってCSRFを防いでいるサイトであっても、OAuthはその性質上セッションを維持したまま外部サイトからのGET等を受け付ける必要がある場合があるため、この機能でのみCSRFが可能な場合があるので注意が必要です。

### 対策
対策は、処理前に充分にランダムなstateを付与し、codeパラメータを処理する前にセッションから読みだしたstateとリダイレクトによって送られてきたstateが同一であるかを検証することです。
なお、この検証を行わない場合であってもセッションに何ら情報が記録されていない場合は、攻撃者がcodeを結びつけるメリットがないため、ログイン機能やログイン前のコミット機能におけるCSRFと同様のリスクとなる場合があります。

## クライアント認証の不備
### 概要
アクセストークンリクエストは、アクセストークン取得のためにクライアントから認可サーバ宛に送信されるリクエストです。アクセストークンリクエスト時にはクライアント認証が必須とされており、ここでの認証に不備があると、正規のクライアントになりすましてアクセストークンを発行可能となります。

### 原因と影響
認可サーバが、アクセストークンリクエスト受信時にクライアントへ認証を要求していないことが原因です。
このような場合、何らかの手段で漏えいした認可コードを用いて、正規のクライアントになりすましたアクセストークン発行が行われる可能性があります。

### 診断観点
認可サーバから得たアクセストークンをサーバに送信していたり、そのアクセストークンによって解決した情報をサーバに送信している場合は注意が必要です。その値が改ざん可能であることを留意した設計になっているか検証する必要があります。

### 対策
アクセストークンリクエスト送信時に、クライアントへ認証を要求します。ここでの認証方式は厳密に指定されておらず、パスワード認証やクライアント証明書などが利用可能です。

## Implicit Grant Flowをサーバと関係した処理で用いる
### 概要
Implicitフローは認可サーバとリソースオーナーのユーザエージェントのみで構成されるアプリケーションにおいて使える機能です。このフローで得た情報をサーバに送信する場合、当該値はリソースオーナーによって改ざん可能であるため、信頼できない値として扱う必要があります。

### 原因と影響
例えばImplicitフローで得られたリソースオーナーの住所をサーバに送信して、リソースサーバから連携された身元情報として取り扱う場合、攻撃者は、リソースサーバから得られた住所を改変して送信することで、リソースサーバによって検証されていない値を登録することができます。

また、クライアントがアクセストークンをリソースオーナーのユーザエージェントから直接受け取っている場合、リソースオーナーは任意のアクセストークンを送信できます。よって当該クライアント向けに発行されたものであるか検証を行わない限り、攻撃者サーバを利用したユーザのアクセストークンを使って、対象サイト上の機能を悪用できる可能性があります。

### 対策
認可サーバとリソースオーナのユーザエージェント以外が関与する場合はImplicitフローではなく、認可コードフローを用いて下さい。

# OpenID Connect
OpenIDConnectにおいても、その一部はOAuth2.0と同様の処理であるため、その共通する処理に関しては前述の問題が起こり得ます。
ただし、OpenID Connect特有の問題もあります。以下ではその問題について解説します。

## IDTokenの検証不備
### 概要
OpenIDConnectにおいては、最終的にユーザのアイデンティティを証明するものとして、JsonWebTokenが発行されます。このトークンには発行元や発行先、有効期限などが保持されており、署名によって正当性を検証できるようになっています。
正当性検証を怠った場合、JWT改ざんによって、なりすまし等の被害が発生するおそれがあります。
### 原因と影響
　署名検証不備
　　トークンの署名検証に不備がある場合、攻撃者はトークンを改ざんできるため、JWT内のパラメータを改ざんすることで、なりすますことが可能です。alg:Noneを指定できる場合や、攻撃者にとって既知の鍵を用いている場合などが不備の典型例です。

### 診断観点
#### alg none
署名検証不備を狙う攻撃として著名なものにJWTヘッダのalgの値にnoneを設定し、署名検証を回避させるものがあります。IDトークンの検証者がnoneの設定を許容している場合、IDトークンに含まれるclaimの値を攻撃者が自由に改ざん可能となり、第三者へのなりすましが容易に可能となります。

#### alg hs256
noneがIdPによって拒否された場合、別のアルゴリズムを指定することで署名検証の不備を突破できる可能性があります。それはHS256です。改ざん対象のIDトークンの署名に用いられた秘密鍵と対になるIdPの公開鍵を特定し、その公開鍵を用いてIDトークンの署名を生成します。この時のIDトークンは、ヘッダのalgの値としてHS256を指定した新たなIDトークンとして生成します。署名に用いたIdPの公開鍵をkidパラメータなどで指定できる場合、IDトークンに含まれるclaimの値を攻撃者が自由に改ざん可能となり、第三者へのなりすましが容易に可能となります。

### 対策
 まず署名検証を正しく行う必要があります。自身がRPの場合、署名検証アルゴリズムは独自に実装せず、ライブラリ等を用いて検証しましょう。自身がidpを担う場合は、ライブラリ使用に加え、JWT署名専用の鍵を生成・保管し鍵を使いまわさないようにしてください。
　加えて、自身がRPの場合は利用しているidpが各クレームをどのように用いているか念のため確認することを推奨します。idpが推奨する利用法や実装に沿って認証機能を実装しましょう。自身がidpの場合は、仕様に沿って各クレームを実装してください。仕様書にないクレームを付与する場合は、その意味や想定される使い方を公開してください。


## リプレイアタック
### 概要
リプレイアタックとは、すでにRPで利用されたIDトークンを再送することで、正規のユーザになりすましてRPへログインすることを試みる攻撃です。
すでに利用済みのIDトークンを利用することから、正規のOIDCフローが完了した後に懸念されます。

### 原因と影響
リプレイアタックが発生する原因にはRPとOPそれぞれの実装不備が関与します。
#### RP
ユーザのセッションと紐づくnonceパラメータを認証リクエストに含めていない、もしくはトークンレスポンス受信時にnonceパラメータを削除していない、のいずれか一方でも満たしていないことが原因です。
#### OP
IDトークンのclaimに、認証リクエストで受け取ったnonceパラメータを含めていないことが原因です。
これによって、何らかの手段でIDトークンを入手した攻撃者によって、正規のユーザになりすましてRPへログインされる可能性があります。

### 診断観点
診断時においては、IDトークンの再送が可能であるかを検査します。
手順として、まず一度OIDCのフローを完了してIDトークンを発行します。その後、別のユーザとしてOIDCのフローを改めて開始し、トークンレスポンス内のIDトークンを、最初に発行したIDトークンに置き換えます。その結果、最初にIDトークンを発行したユーザとしてRPへログインに成功するばあいにリプレイアタックが可能となります。

### 対策
RPとOPのそれぞれで対策が必要です。

#### RP
以下2点のどちらの対応も必須です。
ユーザのセッションに紐づく値を生成し、認証リクエストにnonceパラメータとして含める
IDトークンのclaim内のnonceパラメータとユーザのセッションに紐づく値が一致することを検証し、問題なければセッションからnonceに一致する値を削除する

#### OP
認証リクエストにnonceパラメータが含まれている場合は、発行するIDトークンのclaimにそのnonceパラメータをそのまま含める



