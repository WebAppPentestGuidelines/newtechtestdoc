[{"id":0,"href":"/newtechtestdoc/docs/cloudsec/idaas/edos/","title":"EDoS(Economic Denial of Sustainability) - IDaaS","section":"IDaaSの活用に起因する脆弱性とその悪用","content":" EDoS(Economic Denial of Sustainability) # 概要 # IDaaSをはじめとしたクラウドサービスでは、そのサービスの利用に応じて課金される「従量課金制」を採用しています。 このような従量課金を採用するサービスでは、課金される要素が増加するごとに利用額も増加します。 この特性を攻撃者が悪用することで、サービス提供者がサービスを継続できないレベルまで利用額を増加させる攻撃を、Economic Denial of Sustainability(以下 EDoSと呼称する)と呼びます。\n本稿ではAmazon Cognitoを例に、このEDoSについて解説をしていきます。\n原因 # 「課金される要素が増加する」ことがEDoSを引き起こす原因となります。 Amazon Cognito User Poolでは、外的要因でこの課金額を増加させる方法として、「月間のアクティブユーザー(MAU)の増加」が挙げられます。\nこのMAUはCognito User Poolに対して、サインインやサインアップ等の機能を利用したユーザーを1として加算され、100,000MAU以下の場合、1MAUあたり0.0055USD加算されます。\nMAU MAUあたりの料金 ～ 100,000 0.0055USD 90万 0.0046USD 900万 0.00325USD 1,000万超 0.0025USD このような料金形態を取るCognito User Poolでは、Cognito User Poolのセルフサインアップが有効化されている際に、攻撃者が大量のユーザーを作成することでサービス提供者が意図しない形でMAUが増加し、料金として請求されます。\n影響 # 意図しない利用料金の請求により、サービス提供を行うための予算が利用され、サービスを提供できなくなる恐れがあります。\n事例紹介 # 現時点では現実世界においてCognito User Poolをはじめとして、IDaaSを用いたEDoSや利用料金の増加は報告されていません。ただし、NHK厚生文化事業団が運営する寄付サイトへの偽計業務妨害事案をはじめとして、意図しない課金のためサービスが停止した例や実装の不備により異常な課金が発生した例は報告されています。\n対策 # 対策としては、攻撃者のユーザー作成やログインの自動化を難しくすることで大量のユーザーの追加を防ぐことができるでしょう。\n自動化を難しくする方法として、Custom authentication challengeやAWS WAF等のCognito User Poolの拡張機能を用い、reCaptchaの導入や、Lambdaトリガを用いたEmailアドレスの検証とエイリアス利用の制限等が挙げられます。\n学習方法/参考文献 # EDoS Attack: クラウド利用料金でサービスを止められるって本当？: Amazon Cognito User Pool "},{"id":1,"href":"/newtechtestdoc/docs/cloudsec/idaas/","title":"IDaaSの活用に起因する脆弱性とその悪用","section":"クラウドサービスにおけるWebサービスにまつわる脆弱性","content":" IDaaSの活用に起因する脆弱性とその悪用 # 概要 # 本稿では、Webやモバイルのアプリケーションのユーザーへのサインインおよびサインアップ機能を提供するサービスであるB2C向けのIdentity as a Service(以後 IDaaSと表記する)の活用に起因するアプリケーションの脆弱性について解説します。\nIDaaSとは # IDaaSは大きな区分ではSaaS(Software as a Service)と同じ区分であり、Webやモバイルのアプリケーションのユーザーへのサインインおよびサインアップ機能、ユーザの管理機能などの認証やそれに関わる機能を提供するクラウドサービスです。\n上記のような用途で利用されるIDaaSの例として以下のようなものが存在します。\nAmazon Cognito User Pool Firebase Authentication Google Identity Platform Microsoft Azure AD BtoC Auth0 活用に起因する脆弱性 # ここからは、IDaaSの活用に起因する脅威 / 脆弱性について解説します。\nIDaaSを用いる際に発生しうる脅威 / 脆弱性は大きく分けて3つに分類できます。\n仕様として定義していないアクションの存在が悪性の副作用をもたらすもの 仕様として定義したものが適切にハンドリングされず悪性の副作用をもたらすもの IDaaSから取得した値やTokenの対に完全な信頼をおくことによる、値の悪性作用をもらすもの 本解説では、上記の分類に該当する脆弱性について記述していきます。\n脆弱性 / 脅威 / 悪用 # 意図しないサインアップ経路の存在 権限に関するカスタム属性の変更 デフォルトエラーによるユーザーの存在判定 EDoS(経済的/資金的なサービス停止攻撃) "},{"id":2,"href":"/newtechtestdoc/docs/cloudsec/idaas/modify_custom_attributes_for_permissions/","title":"アプリケーションの権限に関するカスタム属性の変更 - IDaaS","section":"IDaaSの活用に起因する脆弱性とその悪用","content":" アプリケーションの権限に関するカスタム属性の変更 # 概要 # IDaaSの機能を誤って利用することにより、ユーザーに紐づくカスタム属性などの変更が可能になり、アプリケーションにおける権限昇格や意図しないアクセスを引き起こす可能性が存在します。\n原因 # 権限情報に関するカスタム属性を変更する機能のアクセス制御が適切に行われていないことから、第三者が属性を変更し権限を書き換える可能性が存在します。本稿ではAmazon Cognitoの誤った利用を例に原因について解説します。\n誤った利用の例 1. 権限に関する属性が変更可能\nユーザーに対してアプリケーションの権限に関する属性の変更権限を与えることにより、属性を任意の値に変更される恐れがあります。\n$ ACCESS_TOKEN=\u0026#34;eJy...\u0026#34; # JWT形式のアクセストークン $ aws cognito-idp update-user-attributes \\ --user-attributes Name=\u0026#34;custom:role\u0026#34;,Value=\u0026#34;admin\u0026#34; \\ # アプリケーションの権限に関わるカスタム属性の変更 --access-token $ACCESS_TOKEN 誤った利用の例 2. 公開されたクライアントIDによるアクセス制御\n一部IDaaSでは、自らの情報へアクセスを行う際にクライアントIDのような特定の識別子を用いてアクセスを行います。このクライアントIDはユーザの属性に関する変更や閲覧に関する操作を司っており、OIDCにおけるScopeのような動作をします。\nこのクライアントIDを用いてユーザの属性変更に関するアクセス制御をしており、かつ取得に制限のかけられていないJavaSctriptファイルやapkファイルなどにこの管理者用のクライアントIDが含まれている場合、攻撃者はこのクライアントIDを用いてTokenを発行し、自らの権限に関わる属性を変更しアプリケーション内の権限を昇格させることが可能です。\n影響 # 本来であれば閲覧を想定していない第三者が、該当の画面やエンドポイントへアクセスできる可能性があります。\n対策 # 根本的対策 # 根本的対策として、一般ユーザーから権限に関わるカスタム属性の値を変更させないようにしてください。権限に関わるカスタム属性の操作を必要とする場合はRBAC等を用いて管理者権限のユーザーのみが変更できるようにしてください。\nまた、カスタム属性を利用しないで権限を管理する機能がある場合、その機能を用いることも検討してください。\n一時的対策 # 一時的対策として、IDaaSへのIP制限等を行い、管理者利用するIDaaSへの一般ユーザーのアクセスをNWレベルで制限してください。\nまた、本対策を恒久的な対策とせず、根本的な対策を実施してください。\n具体: Amazon Cognito User Pool # Amazon Cognito User Poolにおいては、ユーザーの属性で権限情報を管理可能ですが、Cognito User Poolの管理者APIに対してRBACを実装する場合、このユーザグループを用いて管理することも検討してください。\n学習方法/参考文献 # Amazon Web Service - Amazon Cognito - ユーザープール属性 Amazon Web Service - Amazon Cognito - ユーザーグループ Flatt Security inc. - AWS 診断を事例としたクラウドセキュリティ。サーバーレス環境の不備や見落としがちな Cognito の穴による危険性 "},{"id":3,"href":"/newtechtestdoc/docs/cloudsec/idaas/default_error/","title":"デフォルトエラーに起因するユーザーの開示 - IDaaS","section":"IDaaSの活用に起因する脆弱性とその悪用","content":" デフォルトエラーに起因するユーザーの開示 # 概要 # アプリケーションが返すエラーレスポンスは、攻撃者が攻撃を実施する上での大きなヒントとなることがあります。代表的な例として、Internal Server Error時にサーバ上のプログラムの断片や、SQL文などが見えてしまうことが挙げられます。\n認証においても同様で、認証情報がそのサービスで使われているのかを示す詳細なエラーを返すことにより、攻撃者に標的となるユーザーの存在を知らせてしまう可能性があります。\nそのような観点からIDaaSでもエラーメッセージについては不要な内容の削除や表記の統一を図ることが必要です。\n原因 # CognitoをはじめとするIDaaSのエラーメッセージでは、デフォルトのメッセージが詳細な情報をレスポンスとして返るケースが存在します。\nAuth0の場合 Cognitoの場合 影響 # エラーメッセージにおいてサービスに登録しているユーザーのメールアドレスを確認できます。 攻撃者にメールアドレスを取得され、過去に流出した認証情報との組み合わせをもとに不正ログインを試行される可能性があります。\n対策 # 対策として、デフォルトのエラーメッセージを変更し、認証認可に係るエラーに関して統一されたカスタムメッセージに変更することを推奨します。\nまた、上記の対策が不可能なサービス(Firebase AuthのID/Pass認証)も存在するため、その点を考慮して対策等を行ってください。\n学習方法/参考文献 # Amazon Web Service - Amazon Cognito - エラーレスポンスの管理 Auth0 OWASP チートシート - 認証とエラー メッセージ Amazon Web Service - Amazon Cognito - 認証チャレンジの作成の Lambda トリガー "},{"id":4,"href":"/newtechtestdoc/docs/cloudsec/idaas/presence_of_unintended_signup_paths/","title":"意図しないサインアップ経路の存在 - IDaaS","section":"IDaaSの活用に起因する脆弱性とその悪用","content":" 意図しないサインアップ経路の存在 # 概要 # 管理者画面や会員向けのサービスなどの設計や要件レベルでサインアップ経路を制限しているアプリケーションにおいて、IDaaSの設定不備や誤った利用によって意図しない形でのサインアップが可能になる場合があります。\n原因 # 管理者画面や会員向けのサービスなどの設計や要件レベルでのサインアップ経路の例として、管理者以外のユーザによるユーザ作成を想定していないケースが存在します。本稿ではAmazon Cognitoの誤った利用を例に原因について解説します。\n$ CLIENT_ID=\u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; $ USER_NAME=\u0026#34;username\u0026#34; $ PASSWORD=\u0026#34;P4ssW0rD\u0026#34; $ ATTRIBUTES=\u0026#34;[]\u0026#34; $ aws cognito-idp sign-up \\ --client-id $CLIENT_ID \\ --username $USER_NAME \\ --password $PASSWORD \\ --user-attributes $ATTRIBUTES \\ --no-sign-request 誤った利用の例. サインアップに関する不適切な権限の分離\nAmazon Cognito User Poolをはじめ、一部のIDaaSではクライアントIDのような識別子を用いて発行されるTokenに権限設定しています。Cognitoではアプリクライアントと呼ばれるクライアントIDを用いてTokenを発行しており、このアプリクライアントに設定される権限をOIDCのScopeとして、JWT形式のトークンを発行します。\nこのアプリクライアントを一般ユーザと管理者ユーザで分けて利用している場合、属性へのアクセスに関しては制御可能ですが、サインアップに関してはアプリクライアントを介して制御できません。そのため、本来意図したサインアップ経路を制限できないため、第三者がこのアプリクライアントを介して自己サインアップが行えてしまいます。\n影響 # 本来であれば閲覧を想定していない第三者が、該当の画面やエンドポイントへのアクセスを行える可能性があります。\n対策 # 限定されたサインアップの場合、自己サインアップをはじめとした、利用者が自らユーザを作成できる機能の無効化してください。また、自己サインアップ機能を無効化できない場合、それに準ずる対策が必要となります。\nまた、管理者による作成に際しては、各IDaaSの提供するAPIへのアクセス方法に準拠し管理者用APIを用いて作成していることを確認してください。\n確認リスト # 仕様上、第三者のサインアップを許可していない 第三者のサインアップを許可していない場合 IDaaSの設定で自己サインアップが制御できる 自己サインアップが許可されていない IDaaSの設定で自己サインアップが制御できない 他の機能を用いて認可制御を行える 根本的対策 # 自己サインアップを許可しない設計や要件の場合、根本的対策として該当する機能を無効化し、ユーザによるサインアップを許可しないようにしてください。 無効後に新規作成する際は、RBAC等のアクセス制御を用いて、操作が可能なユーザを限定してください。\n自己サインアップを無効化できない場合は、管理者による新規作成フローにおいて、利用者から操作できないカスタム属性などを用いて該当アカウントが管理者作成のアカウントであることを証明する属性を追加し、認可やアクセス制御の際に確認してください。\n一時的対策 # 一時的対策として、IDaaSへのIP制限等を行い、管理者利用するIDaaSへの一般ユーザーのアクセスをIPレベルで制限してください。\nまた、本対策を恒久的な対策とせず、根本的な対策を用いて順次対策してください。\n具体: Amazon Cognitoの場合 # Amazon Cognito User Poolにおいては、ユーザーの自己サインアップを無効化する機能が存在するので、この機能を無効化してください。\n管理者用APIへのアクセスに際して、Cognito User PoolのユーザーグループとAmazon Cognito ID Poolを用いて、AWSのCognito User Poolの管理者APIへのアクセスが可能な認証情報を発行してください。この発行される認証情報は最小権限の原則にのっとり、ユーザーグループを用いて管理してください。\n根本的な対策にはなりませんが、管理者が特定のIPからのみ接続する場合は、AWS WAFを用いた接続元IP制限によってCognitoのすべてのAPIへのアクセスを制限するという、一時的な対策も可能です。\n具体: Google Identity Platform の場合 # Google Identity Platformにおいては、ユーザーの自己サインアップを無効化する機能が存在するので、この機能を用いて無効化してください。\nまた、管理者APIへのアクセスに際しては、Admin SDKを用いたAPIを実装し、それを介してアクセスしてください。\n具体: Firebase Authentication の場合 # Firebase Authentication においては、ユーザーの自己サインアップ機能が存在しないため、無効化できません。暫定的な対策として、custom claimによる登録フローに関する属性を追加し、セキュリティルールにおけるバリデーションで不正に作成されたユーザが操作できないよう設定してください。\nまた、custom claimに関しては管理者APIへのアクセスが必要なため、Admin SDKを用いたAPIを実装し、それを介してアクセスしてください。\n事例 # Internet-Scale analysis of AWS Cognito Security 学習方法/参考文献 # Amazon Web Service - Amazon Cognito - 管理者作成ユーザーのポリシーの設定 Amazon Cognito における AWS WAF のネイティブサポートが開始 Google Cloud - プロジェクトにおける Identity Platform ユーザー \u0026gt; ユーザーのセルフサービス Flatt Security inc. - Firebase Authentication 7つの落とし穴 - 脆弱性を生むIDaaSの不適切な利用 Flatt Security inc. - AWS 診断を事例としたクラウドセキュリティ。サーバーレス環境の不備や見落としがちな Cognito の穴による危険性 NoSoSecure - Hacking AWS Cognito Misconfigurations 個人ブログ - AWS Cognito Misconfigurations in Android Apps "},{"id":5,"href":"/newtechtestdoc/docs/cloudsec/faas/","title":"FaaSにおける設定不備と脆弱性の悪用","section":"クラウドサービスにおけるWebサービスにまつわる脆弱性","content":" FaaSにおける設定不備と脆弱性の悪用 # 概要 # 本稿では、Webやモバイルのアプリケーションで利用されるプログラムを実行するサービスである、FaaSの活用と、実装や利用方法が起因となるアプリケーションの脆弱性について解説します。\nFaaSとは # FaaS(Function as a Service)は、サーバレスなアプリケーションやマイクロサービスで用いられるサービスです。 一定の制約下でプログラムを実行可能にする、IaaSやPaaSのようにクラウド上で利用可能なコンピュータリソースを提供するサービス形態です。\nFaaSは多くのクラウドベンダーで提供されており、私たちは気付かないうちにこれらサービスと向き合っているかもしれません。\nAWS Lambda Google Cloud Functions Azure Functions Cloudflare Workers Netlify Functions FaaSの特徴として、あるイベントをトリガとしてLambdaにホストされたプログラムを実行することが挙げられます。 Amazon Web Services Japan 形で考えるサーバーレス設計から例を抜粋して紹介します。\nAPI Gateway + Lambda + DynamoDBを用いたAPI APIをサーバレスで構築する際の基本パターンで、API Gatewayへのリクエストをトリガとして実行されます。 S3へアップロード時に画像を加工するためのLambda S3 Bucketへ画像やファイルをアップロードしたイベントをトリガとしてLambdaを実行するデザインパターンです。 SNS + SQS(Queue) + Lambdaを用いた業務処理 各種重要処理や競合/重複状態を回避するために利用されるデザインパターンです。 SNSのPubSub機能を用いて、SQSに投入し、LambdaがそのイベントをトリガとしてQueueに入ったデータを取得し実行されます。 脆弱性 / 脅威 / 悪用 # 本稿では、FaaSの利用や設定ミスによって発生するセキュリティ上の脅威や悪用について、下記のページにて触れていきます。また、Injectionやエラー情報の開示といった「アプリケーションの実装」に起因するものは個別には取り扱いませんのでご了承ください。\n概要 # 多くのクラウドプロバイダが提供するFaaSでは、プログラムを実行する際に用いる環境変数を設定できる機能が存在します。これら環境変数機能を用いることで、FaaS上で動作するアプリケーション等に値を渡すことが可能です。 この機能では基本的にAPIキーやDBの認証情報、IAMの認証情報などの機密性の高い情報を格納することを非推奨の項目としています。しかし、この環境変数内に認証情報を格納することは禁止されているわけではないため、利用者の実装次第ではこれら情報が含まれている可能性が存在します。 このように環境変数を用いることは、直接的な攻撃につながるわけではありませんが潜在的に認証情報が取得される可能性を高めている状況にあります。\n原理 # FaaSの環境変数に格納された認証情報は、/proc/self/environ等から読み取ることが可能で、アプリケーション上の実装の不備をつくことで、入手される可能性があります。\n擬似環境での解説 # 例として、AWS Lambda(AWSの提供するFaaS)上で動作する擬似的な環境をもとに解説をします。\n擬似環境の構成図 このAWS Lambdaには、環境変数にSECRET_KEYという環境変数が設定されており、その値にはSECRET_DUMMYという値が設定されています。そして、動作するコードとして下記のようなJavaScriptのコードが動いています。 このアプリケーションはざっくりな機能として、S3からファイルを取得し、その後Lambda内で加工してクライアントに返すという機能を持っています。 app.js\nvar fs = require(\u0026#39;fs\u0026#39;); var AWS = require(\u0026#39;aws-sdk\u0026#39;); exports.handler = async (event) =\u0026gt; { const file = event.queryStringParameters.file; try { const s3 = new AWS.S3(); const params = { Bucket: \u0026#39;dummy_bucket_name\u0026#39;, Key: file }; const s3_file = await s3.getObject(params).promise(); fs.writeFileSync(`/tmp/${file}`, s3_file.Body); } catch (err) { console.log(err); } /** * ~~画像やファイル操作等の諸々の処理~~ */ const env_file_data = fs.readFileSync(`/tmp/${file}`, \u0026#39;utf8\u0026#39;); const response = { statusCode: 200, body: env_file_data }; return response; }; 上記のアプリケーションでは、API Gatewayからイベントとして送られてきた、queryStringParametersを直接readFileSyncに利用しており、Path Traversal攻撃が発生する状況にあります。 そのため、\u0026quot;../../../../proc/self/environ\u0026quot;と値を入力すると、実装上意図しないローカルファイルが取得できてしまう状況にあります。\nそして、実際に攻撃を受けた際は下記のようなレスポンスが返ってきます。\n{ \u0026#34;statusCode\u0026#34;: 200, \u0026#34;body\u0026#34;: \u0026#34;AWS_LAMBDA_FUNCTION_VERSION=$LATEST\\u0000AWS_SESSION_TOKEN=...\\u0000LD_LIBRARY_PATH=/var/lang/lib:/lib64:/usr/lib64:/var/runtime:/var/runtime/lib:/var/task:/var/task/lib:/opt/lib\\u0000AWS_LAMBDA_LOG_GROUP_NAME=/aws/lambda/vulnfunc\\u0000LAMBDA_TASK_ROOT=/var/task\\u0000AWS_LAMBDA_LOG_STREAM_NAME=2023/02/21/[$LATEST]97a22f53be874c9db31c5ee126df276e\\u0000AWS_LAMBDA_RUNTIME_API=127.0.0.1:9001\\u0000AWS_EXECUTION_ENV=AWS_Lambda_nodejs14.x\\u0000AWS_LAMBDA_FUNCTION_NAME=vulnfunc\\u0000AWS_XRAY_DAEMON_ADDRESS=169.254.79.129:2000\\u0000PATH=/var/lang/bin:/usr/local/bin:/usr/bin/:/bin:/opt/bin\\u0000AWS_DEFAULT_REGION=ap-northeast-1\\u0000SECRET_KEY=SECRET_DUMMY\\u0000PWD=/var/task\\u0000AWS_SECRET_ACCESS_KEY=...\\u0000LAMBDA_RUNTIME_DIR=/var/runtime\\u0000LANG=en_US.UTF-8\\u0000AWS_LAMBDA_INITIALIZATION_TYPE=on-demand\\u0000NODE_PATH=/opt/nodejs/node14/node_modules:/opt/nodejs/node_modules:/var/runtime/node_modules:/var/runtime:/var/task\\u0000AWS_REGION=ap-northeast-1\\u0000TZ=:UTC\\u0000AWS_ACCESS_KEY_ID=....\\u0000SHLVL=0\\u0000_AWS_XRAY_DAEMON_ADDRESS=....\\u0000_AWS_XRAY_DAEMON_PORT=2000\\u0000_LAMBDA_TELEMETRY_LOG_FD=3\\u0000AWS_XRAY_CONTEXT_MISSING=LOG_ERROR\\u0000_HANDLER=index.handler\\u0000AWS_LAMBDA_FUNCTION_MEMORY_SIZE=128\\u0000NODE_EXTRA_CA_CERTS=/etc/pki/tls/certs/ca-bundle.crt\\u0000\u0026#34; } 出力された環境変数を整形すると下記のようになります。環境変数内には先に設定したSECRET_KEYが含まれており、攻撃者に認証情報を取得されてしまったことがわかります。\nAWS_LAMBDA_FUNCTION_VERSION=$LATEST AWS_SESSION_TOKEN=... LD_LIBRARY_PATH=/var/lang/lib:/lib64:/usr/lib64:/var/runtime:/var/runtime/lib:/var/task:/var/task/lib:/opt/lib AWS_LAMBDA_LOG_GROUP_NAME=/aws/lambda/vulnfunc LAMBDA_TASK_ROOT=/var/task AWS_LAMBDA_LOG_STREAM_NAME=2023/02/21/[$LATEST]97a22f53be874c9db31c5ee126df276e AWS_LAMBDA_RUNTIME_API=127.0.0.1:9001 AWS_EXECUTION_ENV=AWS_Lambda_nodejs14.x AWS_LAMBDA_FUNCTION_NAME=vulnfunc AWS_XRAY_DAEMON_ADDRESS=169.254.79.129:2000 PATH=/var/lang/bin:/usr/local/bin:/usr/bin/:/bin:/opt/bin AWS_DEFAULT_REGION=ap-northeast-1 SECRET_KEY=SECRET_DUMMY PWD=/var/task AWS_SECRET_ACCESS_KEY=... AWS_REGION=ap-northeast-1 TZ=:UTC AWS_ACCESS_KEY_ID=.... SHLVL=0 _LAMBDA_TELEMETRY_LOG_FD=3 AWS_XRAY_CONTEXT_MISSING=LOG_ERROR _HANDLER=index.handler NODE_EXTRA_CA_CERTS=/etc/pki/tls/certs/ca-bundle.crt 観点 # もしIAMを顧客から受け取っている場合は、FaaSの環境変数に認証情報が含まれていないことを確認してください。 また、下記のいずれかの脆弱性を有している場合、FaaSに設定された認証情報を取得できる場合があるので、認証情報が含まれていないことを確認をしてください。\nInjection攻撃: FaaS上で任意のコマンドやコードを実行可能なOSコマンドやサーバサイドテンプレート等のInjection攻撃が存在する場合、アプリケーションそのものや、構成要素としてFaaSを利用している可能性を考慮して診断してください 任意のファイルを読み取ることの可能な攻撃: LFI等のパスに関わる攻撃が存在する場合、アプリケーションそのものや、構成要素としてFaaSを利用している可能性を考慮して診断してください 影響 # 認証情報が漏洩し、攻撃者等に悪用される可能性があります。\n対策 # FaaSで動作するアプリケーションの実装時も、通常のアプリケーション同様の脆弱性対策が必要です。 また、クラウドがFaaSに付与しているIAMの認証情報に関しては、FaaSの特性上、環境変数からアクセスを行うため完全な保護は難しい状況にあります。漏洩した場合のリスクを最小化するために、付与する権限は最小限化したうえで、操作元をそのFaaSのみに設定してください。\n学習方法/参考文献 # AWS Lambda 環境変数の使用 AWS Lambdaで秘密情報をセキュアに扱う - アンチパターンとTerraformも用いた推奨例の解説 Google Cloud Functionsの環境変数 Cloudflere Workersの環境変数 Cloudflere Workersのシークレットの取り扱い OWASP Serverless Top 10 Compromised Cloud Compute Credentials: Case Studies From the Wild "},{"id":6,"href":"/newtechtestdoc/docs/nosql_injection/","title":"NoSQL Injection","section":"Docs","content":" NoSQL Injection # 概要 # NoSQLデータベースを利用したWebアプリケーションにおける脆弱性がNoSQL Injectionです。 NoSQLはより柔軟なデータ形式を使用する、SQLを利用しないデータベースシステムを指します。一般的にデータを以下の4つに管理します。\nkey-value型 列指向型 グラフ型 ドキュメント型 NoSQL製品は種類が多く、本ページでは特に採用されることが多いMongoDB と Redisについて一部記載します。\n原因 # NoSQLデータベースは、SQLデータベースとは異なり、クエリを実行する際にデータを構造化された形式で保存する必要がないため、従来のSQL Injectionとは異なる形で攻撃が発生します。こういったことが起こる原因として、以下のようなものが考えられます。\n不十分な入力値の検証 クエリの構築における不適切な処理 データベースの設定不備 影響 # 攻撃者はパラメータを改ざんし、データベースに意図しない挙動をさせることができます。 また、使用するNoSQLの種類によっては任意のJavaScriptを実行される可能性もあります。 よって、アプリケーションの機密性、整合性、可用性を損ないます。\n診断観点/攻撃手法 # Mongo # 以降は脆弱なアプリケーションを利用して、それぞれの攻撃を確認します。\nMongo SSJI # SSJIとは # SSJIは、Server Side JavaScript Injectionが正式名称となっています。これは、JavaScript実行の不適切な設定などによって、攻撃者から送信された不正なJavaScriptコードが、サーバサイド側にて実行されてしまう攻撃手法のことです。\nMongo SSJIについて、DoS攻撃を例に説明します。 MongoDBは、スクリプト言語としてJavaScriptを使うことができます。脆弱なアプリで、$where演算子を利用している箇所に対してtest'; while(1)'を送信します。 すると、無限ループのJavaScriptのコードが実行され、レスポンスが返ってこないことを確認できます。\n否定演算子の挿入 # 否定演算子を挿入について、ログインバイパスを例に説明します。\n正常なリクエストとして、適当な値、{\u0026quot;username\u0026quot;:\u0026quot;admin\u0026quot;,\u0026quot;password\u0026quot;:\u0026quot;admin\u0026quot;}を送信します。適当な値を送信しているので、ログインに失敗していることが確認できます。\n次に、このサイトに対して{\u0026quot;username\u0026quot;:\u0026quot;admin\u0026quot;,\u0026quot;password\u0026quot;:{\u0026quot;$ne\u0026quot;:\u0026quot;\u0026quot;}}を送信します。すると、ログインに成功します。\nMongoDBでは、$neを否定演算子として扱います。この、否定演算子を挿入します。\nPHPなどの言語の仕様である組込みの連想配列処理が悪用され、以下のような配列に変換されます。\narray(\u0026#34;username\u0026#34; =\u0026gt; \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34; =\u0026gt; array(\u0026#34;$ne\u0026#34; =\u0026gt; \u0026#34;pass\u0026#34;)); 上記の値が処理されることで、ユーザー名の部分は username == 'admin'、パスワードの部分は password != 'pass' となります。これにより、passwordに何を指定しても条件式の評価結果がtrueとなり、ログインに成功してしまいます。また、指定した値が存在しなかった場合は登録ユーザ全員がマッチします。\nBlind NoSQL Injection # $regex演算子を利用したパスワードの文字数推測を例に説明します。\nまず、ユーザネームがguest,パスワードはpasswordというアカウントがあります。\nここで、{\u0026quot;username\u0026quot;:\u0026quot;guest\u0026quot;,\u0026quot;password\u0026quot;:\u0026quot;password\u0026quot;}を送信すると、ログインに成功します。\n次に、このパスワードの長さを推測するために$regex演算子を用いた、{\u0026quot;username\u0026quot;:\u0026quot;guest\u0026quot;,\u0026quot;password\u0026quot;:{\u0026quot;$regex\u0026quot;:\u0026quot;^.{7}$\u0026quot;}}と、{\u0026quot;username\u0026quot;:\u0026quot;guest\u0026quot;,\u0026quot;password\u0026quot;:{\u0026quot;$regex\u0026quot;:\u0026quot;^.{8}$\u0026quot;}}をそれぞれ送信してみます。\n7文字推測\n8文字推測\nすると、パスワードの長さが8文字と推測したリクエストにてログインが成功していることが分かります。実際にパスワードである文字列passwordは8文字で、パスワードの文字列の長さが推測できます。今回は文字数を推測しましたが、同様に正規表現を用い、文字種を次々と入れレスポンスの差分をみることで、パスワードの文字列そのものを線形探索するといったこともできます。\nRedis # 意図しないデータの挿入 # NodeJSでRedisを利用する例を説明します。広く使われているqsモジュールは、クエリ文字列にオブジェクトや配列をパラメータとして渡すことができます。Expressのような一般的なフレームワークでは、このモジュールがデフォルトで有効になっています。このような場合、渡された値によっては、後続のすべてのパラメータを上書きできる可能性があります。その結果、意図しない値がkey-valueペアとして格納されることで、意図しないデータを登録されてしまう事が考えられます。\njsonからの受け取りで挿入 # 以下のようなjsonで値を受け取るコードがあったとします。\napp.use(bodyParser.json());\rapp.post(\u0026#39;/\u0026#39;, function (req, res) { redis.set(req.query.key, \u0026#34;default\u0026#34;);\r}); {key : \u0026quot;foo\u0026quot;}を送信すると、以下が実行されます。\nredis.set(\u0026#34;foo\u0026#34;, \u0026#34;default\u0026#34;); ここで、{key : [\u0026quot;foo\u0026quot;, \u0026quot;evil\u0026quot;]}といったリクエストを送信します。すると、 以下のように実行され、本来入れようとしていた末尾のdefaultが削られてしまいます。\nredis.set([\u0026#34;foo\u0026#34;, \u0026#34;evil\u0026#34;], \u0026#34;default\u0026#34;); クエリ文字列からの挿入 # 以下のようにクエリ文字列で値を受け取るコードがあったとします。\napp.post(\u0026#39;/\u0026#39;, function (req, res) { redis.set(req.query.key, \u0026#34;default\u0026#34;);\r}); ?key=fooを送信すると、以下が実行されます。\nredis.set(\u0026#34;foo\u0026#34;, \u0026#34;default\u0026#34;); ここで、?key[]=foo\u0026amp;key[]=evilといったリクエストを送信します。すると、上記と同様に本来入れようとしていた末尾のdefaultが削られてしまいます。\nredis.set([\u0026#34;foo\u0026#34;, \u0026#34;evil\u0026#34;], \u0026#34;default\u0026#34;); 事例紹介 # CVE-2021-22911 # Rocket Chatで見つかったNoSQLInjectionです。 getPasswordPolicy関数で、NoSQL Injectionが実行できます。 認証/認可を必要とせずに、パスワードリセットトークンを流出させることで、アカウントの乗っ取りが可能でした。 管理者アカウントを乗っ取ることで、RCEにつなげることも可能だったようです。\nref : https://www.cve.org/CVERecord?id=CVE-2021-22911\nCVE-2021-20736 # GROWI 日本製のOSSで見つかったNoSQL Injectionです。 Gitの編集ログをみるに、アクセストークンパーサにNoSQL Injectionがありました。\nref : https://weseek.co.jp/ja/news/2021/06/14/growi-nosql-ingection/\nref : JVN#95457785\nCVE-2020-35666 # Software : Steedos Low Code DevOps Platformで見つかったNoSQL Injectionです。\nポストされるパラメータを、X-User-Id[$ne]=1のように書き換える事で、攻撃が実行されます。\nref : https://github.com/steedos/steedos-platform/issues/1245\n対策 # MongoDB # 最新バージョンを使用 入力検証・サニタイズライブラリの利用 mongo-sanitize、mongoose MongoDBにおいては、 where、mapReduce、 group演算子を使用しないようにしましょう。これらの関数は攻撃者が任意のJavaScriptを注入できてしまう可能性があります。また、可能であればmongod.confに以下のように設定しましょう。 javascriptEnabled:false 必要最低限の権限を付与する Redis 意図しないデータの挿入 # 対策として、渡されたパラメータを正しく受け取るように実装しましょう。\n補足資料 # DynamoDB DynamoDB Injection. I have been developing a bunch of… | by Abhay Bhargav | AppSecEngineer | Medium couchdb NOSQL INJECTION memcached The New Page of Injections Book: Memcached Injections A small injection for memcached – HackMag Cassandra br3akp0int: CASSANDRA AND CQL INJECTIONS 参考資料 # NoSQL Injection \u0026gt; Redis NoSQL Injection \u0026gt; Redis. Ever considered injection a problem for… | by Patrick Spiegel | Medium NoSQLi Scanner - PortSwigger GitHub - codingo/NoSQLMap: Automated NoSQL database enumeration and web application exploitation tool. GitHub - digininja/nosqlilab: A lab for playing with NoSQL Injection ペイロードリスト NoSQL injection - HackTricks "},{"id":7,"href":"/newtechtestdoc/docs/oauth/","title":"OAuth/OpenID Connect","section":"Docs","content":" OAuth/OpenID Connect # 概要 # 本章では、OAuth 2.0およびOpenID Connect(OIDC)と、それに関連するしくみについての脆弱性や攻撃手法について説明します。 なお、本ドキュメントに記載する用語、パラメータ名などはRFC 6749およびOpenID Connect Core 1.0 incorporating errata set 1の記載に準拠します。\nOAuth 2.0 # OAuth 2.0は、リソースサーバや認可サーバから見てサードパーティとなるクライアントサーバやアプリケーション等が、その認可に応じてリソースサーバに保存されているリソースオーナの情報を得るための認可フレームワークです。 通常のアプリケーションのようにクライアント/サーバだけではなく、認可サーバ/リソースサーバを含めた三者間の関係でセキュリティを考慮する必要があります。そのため、各パラメータの目的を考えながら、仕様通り正しく実装する必要があります。\n以下では代表的な脆弱性の概要や診断手法について記載します。\nオープンリダイレクタ # 概要 # 認可サーバでの認可が完了すると、リソースオーナのブラウザはredirect_uriパラメータで指定されたURLへリダイレクトされます。 このリダイレクト時にオープンリダイレクタの脆弱性が存在すると、リソースオーナのブラウザが攻撃者の管理するサーバへリダイレクトされ、認可コード／アクセストークンが漏えいします。\n原因と影響 # 認可リクエスト中のredirect_uriパラメータで指定されるリダイレクト先を検証することなく、認可レスポンスのLocationヘッダにそのまま設定していることが原因です。 これによって、被害者（リソースオーナ）が同意した結果を表す認可コードが、攻撃者の指定するURLへ誘導されます。その結果、認可コードが漏えいし攻撃者にアクセストークンを発行される可能性があります。 また、クライアントがImpicit Flowを利用している場合は、認可コードではなくアクセストークンが漏えいします。 なお、認可コード／アクセストークンの漏えいが難しい場合であっても、任意のURLへリダイレクト可能であれば、一般的なオープンリダイレクタと同様の脅威が存在します。\n診断観点 # 診断時においては、認可リクエスト中のredirect_uriに対して任意のURLを指定し、認可レスポンス受信時にそのURLのリダイレクトが発生するかを検証します。 また、不正なscopeの設定など、redirect_uri以外のパラメータの改ざんなどエラーを引き起こし、その際にredirect_uriで指定したURLへのリダイレクトが発生するかも検証します。\n対策 # オープンリダイレクタは認可サーバ側での対策が必要です。 クライアントに対してredirect_uriの事前登録を必須とし、認可リクエスト中のredirect_uriパラメータと完全一致が検証できた場合にのみ、認可レスポンスを返す実装とします。\nまた保険的な対策として、アクセストークンリクエスト中のredirect_uriパラメータの値が、認可リクエストにて送信されていたredirect_uriパラメータの値と、一致することを検証する方法もあります。 これにより、仮にオープンリダイレクタによって漏えいした認可コードを悪用された場合であっても、認可リクエスト中のredirect_uri（攻撃者が指定したURL）とアクセストークン中のredirect_uri（クライアントの正規のURL）が一致しないため、不正なアクセストークン発行を防ぐことが可能です。\nクロスサイトリクエストフォージェリ # 概要 # OAuth 2.0におけるstateパラメータは、端的にはCSRF攻撃を防ぐためのパラメータです。 本パラメータに着眼して認可コードフローを見ると、以下のようになります。\nクライアントサーバは、stateとしてランダムな値を発行し、リソースオーナーのブラウザのセッションと紐づけて保存する ブラウザは、クライアントサーバから発行されたstateを含む認可サーバへのURLへアクセスする 認可サーバは、codeパラメータとともに(2)のリダイレクト時に受け取ったstateをURLに付与してブラウザをクライアントサーバへリダイレクトさせる クライアントサーバは、ブラウザからcodeとstateを受け取り、(1)で保存したstateと一致している場合は以降の処理を実施する このフローにおいてstateパラメータの検証を適切に行っていない場合、以下の手順で攻撃が可能となります。\n攻撃者は、上記フローにのっとって発行された自身のcodeを用いて、そのcodeを付与して被害者ブラウザをクライアントサーバへリダイレクトさせるような罠サイトを作る 罠サイトにアクセスした被害者のセッションと攻撃者のcodeの組をクライアントサーバで処理される 被害者は、攻撃者のアカウントでログインした状態となる 原因と影響 # 前述の通り、原因は、クライアントサーバが、codeパラメータを受け取る際に、stateパラメータを検証していないことです。 これによって、攻撃者のアカウント向けに発行されたcodeパラメータを、被害者に強制させることができます。\nこの影響はサイトや機能によって異なります。 たとえば、会員登録後に他サイトのアカウントと連携設定することで当該サイトのアカウントで会員としてログインできる機能をもったサイトの場合を考えます。この場合、連携設定の際に攻撃者アカウントのcodeを被害者のセッションに強制することで、攻撃者アカウントで当該サイトに被害者としてログインできます。\n診断観点 # 診断時においては、CSRFの観点からstateパラメータを検証する必要があります。\nOAuthはその性質上セッションを維持したまま外部サイトからのGET等を受け付ける必要があります。このため、SameSite属性によってCSRFを防いでいるサイトであっても、CSRF可能となる場合があるので、注意が必要です。\n対策 # 処理前に十分にランダムなstateを付与し、codeパラメータを処理する前にセッションから読み出したstateとリダイレクトによって送られてきたstateが同一であるかを検証します。\nコードインジェクション # 概要 # コードインジェクションとは、攻撃者自身の管理下にあるアプリケーションに対して、OAuthまたはOIDCのリダイレクト時に認可コードを第三者の未使用の認可コードに入れ替える攻撃です。\n原因と影響 # OAuthにおいては、Authorization Code Grantを利用しているクライアントアプリがPKCEを利用していない、もしくは認可サーバがPKCEに対応していないことが原因です。 OIDCにおいては、nonceまたはc_hashを利用していないことが原因です。 攻撃者はあらかじめクライアントアプリに対して発行された、被害者となるリソースオーナーの認可コードを取得します。 そして、認可レスポンスの Location ヘッダに含まれるURIのクエリパラメータの認可コードの値をあらかじめ取得した被害者の認可コードと入れ替えます。 これにより、攻撃者はリソースオーナーのリソースに不正にアクセスできます。\n診断観点 # OAuthのフロー開始後、PKCE関連のパラメータが送信されているか、その値が適切に検証されているかを検査する必要があります。 認可リクエストにおいては、code_challengeおよびcode_challenge_method パラメータが送信されているかを確認します。 送信されている場合にはいずれか一方の値を適当な値に改ざんしてもフローが正常に完了するか検査します。 トークンリクエストにおいては、code_verifierを含めないもしくは正規のcode_verifier以外の値に改ざんしてもフローが正常に完了するか検査します。\nOIDCのフロー開始後、IDトークンのnonceまたはc_hashがクライアントアプリで適切に検証されているか検査する必要があります。 認証リクエストにおいて、nonceもしくはcodeを入れ替えることでフローが正常に完了するか検査します。\n対策 # OAuthのコードインジェクション対策として、PKCEに準拠した実装が有効です。PKCEにより認可サーバで認可コードの入れ替えを検知できます。\nOIDCのコードインジェクション対策として、nonceとc_hashがあります。 nonceを利用することで、IDトークンと認証リクエストを紐づけることが可能となります。クライアントアプリがIDトークンを受け取ったら、nonceを検証することで、トークンレスポンスにおいて攻撃を検知できます。 c_hashが利用できるのは response_typeの値にid_tokenとcodeの両方が含まれるハイブリッドフローです。クライアントアプリがIDトークンのc_hashを検証することで、認証レスポンスにおいて攻撃を検知できます。\nクライアント認証の不備 # 概要 # アクセストークンリクエストは、アクセストークン取得のためにクライアントから認可サーバ宛に送信されるリクエストです。アクセストークンリクエスト時にはクライアント認証が必須とされており、ここでの認証に不備があると、正規のクライアントになりすましてアクセストークンを発行可能となります。\n原因と影響 # 認可サーバが、アクセストークンリクエスト受信時にクライアントへ認証を要求していないことが原因です。 このような場合、何らかの手段で漏えいした認可コードを用いて、正規のクライアントになりすましたアクセストークンを発行される可能性があります。\n診断観点 # 認可サーバから得たアクセストークンをサーバに送信していたり、そのアクセストークンによって解決した情報をサーバに送信している場合は注意が必要です。その値が改ざん可能であることを留意した設計になっているか検証する必要があります。\n対策 # アクセストークンリクエスト送信時に、クライアントへ認証を要求します。ここでの認証方式は厳密に指定されておらず、パスワード認証やクライアント証明書などが利用可能です。\nImplicit Grant Flowをサーバと関係した処理で用いる # 概要 # Implicitフローは認可サーバとリソースオーナーのユーザエージェントのみで構成されるアプリケーションにおいて使える機能です。このフローで得た情報をサーバに送信する場合、当該値はリソースオーナーによって改ざん可能であるため、信頼できない値として扱う必要があります。\n原因と影響 # たとえばImplicitフローで得られたリソースオーナーの住所をサーバに送信して、リソースサーバから連携された身元情報として取り扱う場合を考えます。この場合攻撃者は、リソースサーバから得られた住所を改変して送信することで、リソースサーバによって検証されていない値を登録できます。\nまた、クライアントがアクセストークンをリソースオーナーのユーザエージェントから直接受け取っている場合、リソースオーナーは任意のアクセストークンを送信できます。よって当該クライアント向けに発行されたものであるか検証しない限り、攻撃者サーバを利用したユーザのアクセストークンを使って、対象サイト上の機能を悪用できる可能性があります。\n対策 # 認可サーバとリソースオーナのユーザエージェント以外が関与する場合はImplicitフローではなく、認可コードフローを用いてください。\nOpenID Connect # OpenID Connectにおいても、その一部はOAuth 2.0と同様の処理であるため、その共通する処理に関しては前述の問題が起こり得ます。 ただし、OpenID Connect特有の問題もあります。以下ではその問題について解説します。\nIDTokenの検証不備 # 概要 # OpenID Connectにおいては、最終的にユーザのアイデンティティを証明するものとして、JsonWebTokenが発行されます。このトークンには発行元や発行先、有効期限などが保持されており、署名によって正当性を検証できるようになっています。 正当性検証を怠った場合、JWT改ざんによって、なりすまし等の被害を発生させる恐れがあります。\n原因と影響 # トークンの署名検証に不備がある場合、攻撃者はトークンを改ざんできるため、JWT内のパラメータを改ざんすることで、なりすますことが可能です。alg:Noneを指定できる場合や、攻撃者にとって既知の鍵を用いている場合などが不備の典型例です。\n診断観点 # alg none # 署名検証不備を狙う攻撃として著名なものにJWTヘッダのalgの値にnoneを設定し、署名検証を回避させるものがあります。IDトークンの検証者がnoneの設定を許容している場合、IDトークンに含まれるclaimの値を攻撃者が自由に改ざん可能となり、第三者へのなりすましが容易に可能となります。\nalg hs256 # noneがIdPによって拒否された場合、別のアルゴリズムを指定することで署名検証の不備を突破できる可能性があります。それはHS256です。改ざん対象のIDトークンの署名に用いられた秘密鍵と対になるIdPの公開鍵を特定し、その公開鍵を用いてIDトークンの署名を生成します。この時のIDトークンは、ヘッダのalgの値としてHS256を指定した新たなIDトークンとして生成します。署名に用いたIdPの公開鍵をkidパラメータなどで指定できる場合、IDトークンに含まれるclaimの値を攻撃者が自由に改ざん可能となり、第三者へのなりすましが容易に可能となります。\n対策 # まず署名検証を正しく行う必要があります。自身がRPの場合、署名検証アルゴリズムは独自に実装せず、ライブラリ等を用いて検証しましょう。自身がIdPを担う場合は、ライブラリ使用に加え、JWT署名専用の鍵を生成・保管し鍵を使いまわさないようにしてください。 加えて、自身がRPの場合は利用しているIdPが各クレームをどのように用いているか念のため確認することを推奨します。IdPが推奨する利用法や実装に沿って認証機能を実装しましょう。自身がIdPの場合は、仕様に沿って各クレームを実装してください。仕様書にないクレームを付与する場合は、その意味や想定される使い方を公開してください。\nリプレイアタック # 概要 # リプレイアタックとは、すでにRPで利用されたIDトークンを再送することで、正規のユーザになりすましてRPへログインすることを試みる攻撃です。 すでに利用済みのIDトークンを利用することから、正規のOIDCフローが完了した後に懸念されます。\n原因と影響 # リプレイアタックが発生する原因にはRPとOPそれぞれの実装不備が関与します。\nRP # ユーザのセッションと紐づくnonceパラメータを認証リクエストに含めていない、もしくはトークンレスポンス受信時にnonceパラメータを削除していないことが原因です。\nOP # IDトークンのclaimに、認証リクエストで受け取ったnonceパラメータを含めていないことが原因です。 これによって、何らかの手段でIDトークンを入手した攻撃者によって、正規のユーザになりすましてRPへログインされる可能性があります。\n診断観点 # 診断時においては、IDトークンの再送が可能であるかを検査します。 手順として、まず一度OIDCのフローを完了してIDトークンを発行します。その後、別のユーザとしてOIDCのフローをあらためて開始し、トークンレスポンス内のIDトークンを、最初に発行したIDトークンへ置き換えます。その結果、最初にIDトークンを発行したユーザとしてRPへログインに成功する場合、リプレイアタックが可能となります。\n対策 # RPとOPのそれぞれで対策が必要です。\nRP # 以下3点のどちらの対応も必須です。\nユーザのセッションに紐づく値を生成し、認証リクエストにnonceパラメータとして含める IDトークンのclaim内のnonceパラメータとユーザのセッションに紐づく値が一致することを検証する 検証後にセッションからnonceに一致する値を削除する OP # 認証リクエストにnonceパラメータが含まれている場合は、発行するIDトークンのclaimにそのnonceパラメータをそのまま含める。\n"},{"id":8,"href":"/newtechtestdoc/docs/prototype_pollution/","title":"Prototype Pollution","section":"Docs","content":" Prototype Pollution # 概要 # JavaScriptでは主に\u0026quot;継承\u0026quot;を実現するための__proto__プロパティが存在します。 Prototype Pollutionは、この__proto__プロパティを通じて特定のオブジェクトの内容を不正に変更する攻撃手法またはそれに対する脆弱性です。\n影響 # Prototype Pollutionの影響は、さまざまで発生箇所やアプリケーションのロジックに依存します。 最悪の場合ではサーバサイドでの任意コード実行につながることがあり、そのほかの場合ではXSSやSQLインジェクションなどの脆弱性にもつながる可能性があります。\n原因 # 攻撃者が__proto__プロパティなどを経由して、特定のオブジェクトのprototypeを操作可能であることがPrototype Pollutionの原因です。\n攻撃手法 # 実際にオブジェクトの__proto__プロパティが操作可能なケースとして、下記2つの例を紹介します。\nオブジェクトに対してmergeやcloneの操作をするケース setValue(obj, key, value)のようにオブジェクトのプロパティを設定するケース 1. オブジェクトに対してmergeやcloneの操作を行うケース # 以下のmerge(tgt, src)は、引数のtgtオブジェクトにsrcのプロパティを再帰的にマージします。 この実装では与えられたオブジェクトのkeyの値をチェックしておらず、任意のkeyに対して任意の値を代入できます。(10行目)\nfunction isObject(obj) { return obj !== null \u0026amp;\u0026amp; typeof obj === \u0026#39;object\u0026#39;; } function merge(tgt, src) { for (let key in src) { if (isObject(tgt[key]) \u0026amp;\u0026amp; isObject(src[key])) { merge(tgt[key], src[key]); } else { tgt[key] = src[key]; } } return tgt; } merge( {a: 1, b: 2}, JSON.parse(\u0026#39;{\u0026#34;__proto__\u0026#34;: {\u0026#34;polluted\u0026#34;: 1}}\u0026#39;) ); const obj = {}; console.log(obj.polluted); // =\u0026gt; 1 上記のPoCでは、引数srcに{\u0026quot;__proto__\u0026quot;: {\u0026quot;polluted\u0026quot;: 1}}というオブジェクトを渡しています。その値を10行目でtgt[__proto__] = {\u0026quot;polluted\u0026quot;:1}のような代入が実行されることで攻撃が成功しています。\n2. setValue(obj, key, value)のようにオブジェクトのプロパティを設定するケース # 以下のsetValue(obj, key, value)は、引数のobjオブジェクトに{key:value}のプロパティを追加します。また、keyにチェーン演算子を用いて指定することで深くに位置するプロパティを追加します。\nこの実装でも引数keyの値をチェックしておらず、任意のkeyに対して任意の値を代入できます。(13行目)\nfunction isObject(obj) { return obj !== null \u0026amp;\u0026amp; typeof obj === \u0026#39;object\u0026#39;; } function setValue(obj, key, value) { const keylist = key.split(\u0026#39;.\u0026#39;); const e = keylist.shift(); if (keylist.length \u0026gt; 0) { if (!isObject(obj[e])) obj[e] = {}; setValue(obj[e], keylist.join(\u0026#39;.\u0026#39;), value); } else { obj[key] = value; return obj; }} setValue({}, \u0026#34;__proto__.polluted\u0026#34;, 1); const a = \u0026#34;\u0026#34;; console.log(a.polluted); // =\u0026gt; 1 上記のPoCでは、引数keyに__proto__.pollutedという値を渡しています。その値が再帰的に処理されることで結果的に13行目でobj[__proto__][polluted] = 1のような代入が実行されることで攻撃が成功しています。\n事例紹介 # NVD - cve-2019-7609 #1106238 Stored XSS via Mermaid Prototype Pollution vulnerability #454365 Prototype pollution attack through jQuery $.extend 対策 # Prototype Pollutionの対策にはいくつか方法があるため、アプリケーションの規模や副作用を考慮して、適切な対策を選択するようにしてください。 ここでは代表的な下記5つの方法を紹介します。\nライブラリを利用する方法 Object.freezeを使用する方法 Objectの代わりにMapを使う方法 オブジェクトの作成をObject.create(null)で行う方法 Schema validation of JSON input ライブラリを利用する方法 # 要件を満たす場合、Prototype Pollutionの影響を受けずにオブジェクトに対してmergeやcloneを行うライブラリを利用することで防ぐことができます。\nObject.freezeを使用する方法 # Object.freeze()を使用して、ObjectやObject.prototypeを変更できないようにすることで、prototypeが意図せず汚染されないようにできます。\n下記のコードは、実際にObject.freeze()を使用して実際に対策できることを示すPoCです。\nObject.freeze(Object.prototype); Object.freeze(Object); ({}.__proto__.test = 123); console.log({}.test); // =\u0026gt; undefined なお、注意点として、（上記のPoCを実際に動かしてみてもわかる通り、）Object.freeze()によってfreezeされたオブジェクトの変更は、特にエラーや例外が起こることなく失敗します。 そのため、本対策を適用し意図しない副作用が発生した場合でも、その発見が困難な場合もあります。 したがって、この対策は（依存ライブラリを含めた）アプリケーションの現状の実装を考慮して、慎重に適用することを推奨します。\nObjectの代わりにMapを使う方法 # ES6以降では、Objectの代わりにMapが利用できます。 Objectで単純にkey/valueのデータ構造を利用している場合は、それらをMapに置き換えることで、Prototype Pollutionを防ぐことができます。\nオブジェクトの作成をObject.create(null)で行う方法 # Object.create()にnullを渡し、prototypeを引き継がないオブジェクトを作成することで、__proto__経由でprototypeが汚染されることを防ぐことができます。 下記のようなコードで、実際に__proto__経由でprototypeにアクセスできないことを実際に確認できます。\nvar obj = Object.create(null); console.log(obj.__proto__ === Object.prototype); // =\u0026gt; false console.log(obj.__proto__); // =\u0026gt; undefined もし{\u0026quot;a\u0026quot;: 1, \u0026quot;b\u0026quot;: 2}のようなもともといくつかのプロパティを持つオブジェクトを作成する場合は、下記のようにObject.assign()を併せて利用する必要があります。\nvar obj = Object.assign(Object.create(null), { a: 1, b: 2 }); なお、このように作成されたオブジェクトのprototypeはObject.prototypeの参照ではありません。そのため、hasOwnProperty()のようなObject.prototypeのメソッドはプロトタイプチェーン経由で呼び出せません。 もし、そのようなメソッドを呼び出したい場合はObject.prototype.hasOwnPropertyのように明記する必要があります。\nvar obj = Object.create(null); obj.a = 1; Object.prototype.hasOwnProperty.call(obj, \u0026#34;a\u0026#34;); // =\u0026gt; true Object.create(null)による本対策を適用する場合は、このような副作用に留意してください。\nSchema validation of JSON input # JSON SchemaではadditionalProperties:falseを指定することで、想定していないプロパティを禁止できます。 適切なJSON Schemeを用いてバリデーションを行うことでPrototype Pollutionの対策ができます。\n以下は、前述の関数setValue()に対し、ajvを用いて対策する例です。\nconst schema = { type: \u0026#34;object\u0026#34;, properties: { // 想定しているプロパティ }, additionalProperties: false, }; const validate = ajv.compile(schema); function setValue(obj, key, value) { const keylist = key.split(\u0026#34;.\u0026#34;); const e = keylist.shift(); if (keylist.length \u0026gt; 0) { if (!isObject(obj[e])) obj[e] = {}; setValue(obj[e], keylist.join(\u0026#34;.\u0026#34;), value); } else { obj[key] = value; if (!validate(obj)) { // handling throw \u0026#34;Invalid Obj\u0026#34;; } return obj; } } setValue({}, \u0026#34;__proto__.polluted\u0026#34;, 1); // =\u0026gt; Exception raised ただし、この場合、propertiesに含んでいないプロパティは一切追加ができなくなることに注意が必要です。 任意のプロパティを受け入れつつ対策をする場合、単に追加されるkeyに悪意のある値が指定されないように制限する対策も有効です。\nfunction setValue(obj, key, value) { const keylist = key.split(\u0026#34;.\u0026#34;); const e = keylist.shift(); if (keylist.length \u0026gt; 0) { if (!isObject(obj[e])) obj[e] = {}; if (e !== \u0026#34;__proto__\u0026#34; \u0026amp;\u0026amp; e !== \u0026#34;constructor\u0026#34;) { setValue(obj[e], keylist.join(\u0026#34;.\u0026#34;), value); } } else { obj[key] = value; return obj; } } setValue({}, \u0026#34;__proto__.polluted\u0026#34;, 1); const a = \u0026#34;\u0026#34;; console.log(a.polluted); // =\u0026gt; undefined 診断方法 # 基本的な診断方法 # これまでに説明したPrototype Pollutionの基本原理や攻撃手法などを踏まえ、任意のオブジェクトのprototypeが不正に変更できないかを検証してください。\nDOM Invaderを用いた効率的な診断 # DOM InvaderはBurpSuiteの機能でDOM XSSのテストやpostMessage()の操作を用いたテストの支援を提供します。この機能を用いることでクライアントサイドのPrototype Pollutionの自動検出や手動での検証の補助として利用可能です。\n詳しい検証方法はTesting for client-side prototype pollutionで丁寧に解説されているので、こちらを参照してください。\n学習方法/参考文献 # HoLyVieR/prototype-pollution-nsec18: Content released at NorthSec 2018 for my talk on prototype pollution Olivier Arteau \u0026ndash; Prototype pollution attacks in NodeJS applications - YouTube Node.js における prototype 汚染攻撃への対策 - SST エンジニアブログ 【1 分見て】実例から学ぶ prototype pollution【kurenaif 勉強日記】 - YouTube Prototype pollution: The dangerous and underrated vulnerability impacting JavaScript applications | The Daily Swig BlackFan/client-side-prototype-pollution: Prototype Pollution and useful Script Gadgets Object.prototype.proto - JavaScript | MDN "},{"id":9,"href":"/newtechtestdoc/docs/toctou/","title":"TOCTOU/レースコンディション","section":"Docs","content":" TOCTOU/レースコンディション # 概要 # システム開発のセキュリティにおいてレースコンディションと TOCTOU は、しばしば混同して使われることがありますが、それぞれの違いについて用語の整理から確認していきましょう。\nレースコンディション(Race Condition)とは、複数の処理が同じデータに対してアクセスしたときに、競合状態になることで想定外の処理が引き起こされる問題です。\n対して TOCTOU(Time Of Check To Time Of Use)とは、あるデータの検証時点と使用時点での状態の差異によって想定外の処理が引き起こされる問題です。\nつまりレースコンディションは、さまざまな競合状態の問題を表す包括的な脆弱性なのに対し、TOCTOU はより実装の状況を限定した具体的な脆弱性であることが分かります。\n本章では、主に TOCTOU に関連する脆弱性や攻撃手法について説明します。\n原因 # TOCTOU は主にデータの検証と使用のタイミングが異なっていることに起因しています。\nそのため、TOCTOU を対策する考え方としては、データのチェックと使用を同時に行い、処理の差を発生させないようにすることが理想的です。\n影響 # 代表的な影響の例として、許可されていないデータへのアクセスやある操作の回数制限を超えた実行などが考えられます。 しかしながら、データの内容や重要性、アプリケーションの振る舞いといったビジネスロジックによって TOCTOU による影響範囲は大きく異なります。\nここでは TOCTOU が発生しやすい機能を例にあげます。\n送金処理 クーポンやキャンペーンコード等の発行や使用 アカウントの新規登録 「高評価」や「いいね」などの投票機能 診断観点/攻撃手法 # 一般的に、DAST のようなツールを使用して TOCTOU の脆弱性を特定することは困難です。\nこれは、競合状態を引き起こした状態と正常な Web アプリケーションの振る舞いの違いを機械的に判断することは難しいためです。\nまた、TOCTOU の診断はミリ秒単位で調整されたリクエスト送信や単一の HTTP パイプライン内で複数の HTTP リクエストを送る診断が必要になります。そのため、Web アプリケーション診断に特化した専門ツール(Burp Suite など)が必要になります。\nこのように、競合状態を起こすための条件や環境を整える必要がある性質上、ほかの Web アプリケーション脆弱性診断に比べて手動によるテストの難易度が高いと考えられています。\n具体的には、実行回数に制限があるような機能や重複防止の制限が設けられている機能などで TOCTOU の診断が有用です。\nBurp Intruder を使用した診断 # Burp に搭載されている機能の 1 つである Burp Intruder を使用して TOCTOU の診断を確認するパターンを紹介します。 なお、 Community Edition には機能制限があるため Pro Edition でしか診断できません。 Community Edition を使用する場合は、後述する Turbo Intruder を使用した診断方法をご覧ください。\n始めに、送信したいリクエストを Burp Intruder にセットします。\nBurp Intruder を開始するにはペイロードポジションを設定する必要がありますが、ペイロードによる作用を防ぎたいです。 そのため、ダミー用のリクエストヘッダ(x-dummy)を用意し、ダミー用ヘッダの値にペイロードポジションを設定します。\n次に、ペイロードを設定します。\nPayload TypeをNull payloadsに設定します。\nGenerate の空白欄に送信したいリクエスト数を入力します。\nデフォルトでは同時に 10 リクエストを送信します。\nより多くのリクエストを送信したい場合は、Resource Pool設定から新しいリソースプール設定を作成し、Maximum concurrent requestsを設定してください。\nTurbo Intruder を使用した診断 # Burp Suite の拡張機能として公開されている Trubo Intruder を使用したパターンを紹介します。\nTurbo Intruder は、大量の HTTP リクエストを送信したり、Python を使用して柔軟にリクエスト前後の処理を操作できる拡張機能です。\nまた、Turbo Intruder は、標準の Burp Intruder とは異なり Community Edition でも使用できます。\n注意\nTurbo Intruder は、Port Swigger 社のセキュリティリサーチャーである James Kettle 氏によって開発されています。しかし、十分なテストが行われていないため Burp の標準機能よりも信頼性がなく、システムパフォーマンスに影響を及ぼす可能性があるため、自己責任のもと拡張機能を使用してください。 送信したいリクエストを選択し、コンテキストメニューからExtensions-\u0026gt;Turbo Intruder-\u0026gt;Send to turbo intruderをクリックして、Turbo Intruder へリクエストを送ります。\n別のウィンドウが表示されます。\nTurbo Intruder も Burp Intruder と同様にペイロードポジションを設定する必要があります。 ここではダミー用のリクエストヘッダ(x-dummy)を用意し、ダミー用ヘッダの値に%s をセットしてペイロードポジションを設定します。\n次にドロップダウンリストから「examples/race.py」を選択します。\nデフォルトでは同時に 30 リクエスト送信する設定になっています。 例として 10 リクエスト送信したい場合は、9 行目のrange関数の引数を修正します。\n事例紹介 # https://github.com/reddelexc/hackerone-reports/blob/master/tops_by_bug_type/TOPRACECONDITION.md 対策 # データの整合性を保つ設計にする必要があります。しかしながら、Web アプリケーション毎に実装やデザインが異なるため、具体的な方法は多岐に分かれます。\nデータのチェックからデータ更新までの一連の処理が完了するまで、ほかのスレッドやプロセスからアクセスできないようにしてください。 データベースで管理している場合はトランザクションを行い、読み書きする情報にロックを掛ける実装にしてください。 ロックの範囲が広すぎると脆弱性の発生箇所とは異なる箇所でデッドロックが発生したり、トランザクション処理によってパフォーマンスにも影響を及ぼす可能性があるため注意してください。 学習方法/参考文献 # https://timegaptheory.com/index.html "},{"id":10,"href":"/newtechtestdoc/docs/cloudsec/cloud_credential/","title":"Webアプリケーションの脆弱性を利用した認証情報の窃取","section":"クラウドサービスにおけるWebサービスにまつわる脆弱性","content":" Webアプリケーションの脆弱性を利用した認証情報の窃取 # 概要 # クラウド環境を利用してWebサービスを提供するシステムにおいて、脆弱性を利用されクラウドサービス側の認証情報（認証キー・APIトークンなど）を窃取されてしまう可能性が危険視されています。 これらの認証情報が漏洩した場合には、漏洩した認証情報に紐づく権限を利用され、クラウドプラットフォーム側の機能を悪用されてしまう危険性があります。 上記のような攻撃には従来から存在するWebアプリケーションの脆弱性を利用される可能性があります。\n原因と影響 # 認証情報の種類や存在する場所などについては、利用しているクラウドプラットフォームやサービスの種類によって異なります。 あくまで一例ですがシステム内の環境変数・設定ファイルなどにこれらの認証情報が設定されているケースが多く、Webアプリケーションの脆弱性を利用されることによって窃取されてしまう危険性があります。\nWebアプリケーションにて詳細情報を表示するエラー画面などから環境変数に設定された認証情報が漏洩 ディレクトリトラバーサルの脆弱性を利用されて、設定ファイルに記載された認証情報が漏洩 また、AWSなどのパブリッククラウドサービスではメタデータサービスと呼ばれる機能が存在します。 この機能では、メタデータと呼ばれるインスタンス固有のデータ(インスタンスID、OSデータ、一時的に付与される認証情報など)を内部Web APIを通じて取得するといったしくみが提供されています。 SSRF(Server Side Request Forgery)の脆弱性を利用することで、この機能を悪用してメタデータを不正に取得され、認証情報を窃取されてしまう攻撃手法が知られています。\n診断観点 # 本記事ではAWS環境を題材にSSRFの脆弱性を利用して、認証情報を取得する流れについて紹介します。\nSSRFは、攻撃者が指定した任意のサーバに対してHTTPリクエストを行うように、サーバサイドアプリケーションを誘導させるというものです。 これを利用して、攻撃者は脆弱性の存在するサーバを踏み台として他サーバにアクセスしたり、自身が直接到達できないサーバに対してアクセスできます。\n脆弱性の例として、以下のPHPのサンプルコードを用意しました。\n\u0026lt;?php\rif (isset($_GET[\u0026#39;url\u0026#39;])){\r$url = $_GET[\u0026#39;url\u0026#39;];\r$conn = curl_init();\rcurl_setopt($conn, CURLOPT_URL, $url);\rcurl_setopt($conn, CURLOPT_RETURNTRANSFER, true);\r$res = curl_exec($conn);\recho $res;\rcurl_close($conn);\r}\r?\u0026gt; GETパラメータで取得したURL値に対して、PHPのcURL関数によりHTTPリクエストを送信し、結果を出力するだけのシンプルなコードです。 もしこのようなWebアプリケーションが存在し、公開されていた場合にはSSRF攻撃を受けてしまう可能性があります。 上記で説明したように、このWebアプリケーションではurlパラメータに指定した値をそのままcURL関数にて取得する実装となっています。 そのため、クライアント側がurlパラメータに任意のURL値を指定して受け渡すことで、Webアプリケーションに指定したURLの対象に対してアクセスさせ、レスポンスを取得できます。\nこの挙動を利用することで、以下の図のように攻撃者は本来アクセスできないような対象に対して、Webアプリケーションを経由してアクセスを行い、情報を取得できます。 これは、SSRFを用いた内部ネットワークへの攻撃の一例となります。\nもし、クラウド環境にて提供されているWebアプリケーションに上記のようなSSRFの脆弱性が存在する場合には、この機能を悪用され、メタデータを不正に取得されてしまう可能性があります。以下の図では、AWS環境におけるSSRF攻撃を記載しています。\n図ではIAMロールが紐づいた状態のEC2インスタンスにおけるSSRF攻撃によって、Webアプリケーション側がメタデータサーバのAPIへ一時的な認証情報を要求するリクエストを強制させられています。 その結果、EC２のIAMロールに紐づいた認証情報を窃取されてしまう流れを記載しています。 ここでは、EC2にアタッチされているIAMロールに関連付けられた認証情報を、この図のようなSSRF攻撃によって取得する流れの詳細を説明します。\nAWSのメタデータサーバに関する仕様は以下に記載されています。\nインスタンスメタデータとユーザーデータ EC2インスタンス上より上記仕様に記載されているURLにアクセスすることで、該当するメタデータの情報を取得できます。 EC2インスタンスにアタッチされたIAMロールが存在する場合には、以下のメタデータサーバのURLにアクセスすることで、認証情報を取得できます。\nhttp://169.254.169.254/latest/meta-data/iam/security-credentials/[role-name] 上記のパス中の[role-name]の部分にはEC2にアタッチされているIAMロールの名前を指定する必要があります。 上記URLにアクセスすることで指定したIAMロールに関連付けられた一時的なセキュリティ認証情報が格納される仕様となっています。なお、IAMロール名は以下のURLアクセスすることで取得できます。\nhttp://169.254.169.254/latest/meta-data/iam/security-credentials/ AWSのEC2上でSSRFの脆弱性が存在するサンプルコードのWebアプリケーション(ssrf.php)が動作しているとします。 まず、SSRFの脆弱性を利用してメタデータサーバのURLをパラメータ値として脆弱性の存在するWebアプリケーションに送信することによって、EC2にアタッチされたrole-nameを取得します。\nリクエストURL ssrf.php?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/ レスポンス HTTP/1.1 200 OK\rDate: Wed, 22 Feb 2023 17:22:20 GMT\rServer: Apache/2.4.55 () PHP/5.4.16\rUpgrade: h2,h2c\rConnection: Upgrade, close\rX-Powered-By: PHP/5.4.16\rContent-Length: 7\rContent-Type: text/html; charset=UTF-8\rec2role そして、取得したrole-nameを利用してパスの一部を変更したURLの値を送信します。 同様のSSRFの脆弱性を利用することで、一時的に発行された認証情報を取得できます。\nリクエストURL ssrf.php?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/ec2role レスポンス HTTP/1.1 200 OK\rDate: Wed, 22 Feb 2023 17:23:48 GMT\rServer: Apache/2.4.55 () PHP/5.4.16\rUpgrade: h2,h2c\rConnection: Upgrade, close\rX-Powered-By: PHP/5.4.16\rContent-Length: 1450\rContent-Type: text/html; charset=UTF-8\r{\r\u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34;,\r\u0026#34;LastUpdated\u0026#34; : \u0026#34;2023-02-22T17:22:41Z\u0026#34;,\r\u0026#34;Type\u0026#34; : \u0026#34;AWS-HMAC\u0026#34;,\r\u0026#34;AccessKeyId\u0026#34; : \u0026#34;ASIAXXXXXXXXXXXXXXXX\u0026#34;,\r\u0026#34;SecretAccessKey\u0026#34; : \u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;,\r\u0026#34;Token\u0026#34; : \u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;,\r\u0026#34;Expiration\u0026#34; : \u0026#34;2023-02-22T23:56:46Z\u0026#34;\r} ※認証情報の部分は伏字としています。\nこのようにして、SSRF攻撃によって認証情報を取得されてしまった場合には、取得された認証情報に紐づく権限を悪用され、被害が拡大してしまう可能性があります。 また、上記のサンプルコードのように送信したURL値の処理に起因するような脆弱性ではなくとも同じ攻撃は成立します。 たとえば以下のようなほかの脆弱性が存在した場合には、その脆弱性を利用することによってアプリケーションに任意のURLにアクセスを行わせるようなSSRF攻撃ができるでしょう。 その結果、同様に認証情報を窃取できる可能性があります。\nXXE OSコマンドインジェクション なお、上記はあくまで一例です。 本記事にては解説したように、クラウド環境のWebサービスでは、Webアプリケーションの脆弱性を利用されてクラウド環境側の認証情報の取得などにつながってしまう可能性があります。 そのため脆弱性診断では、上記のようなケースを想定したうえで、評価する必要があると考えます。 従来から知られているWeb脆弱性を検出する手法についてはWebアプリケーション脆弱性診断ガイドラインをご参照ください。\nWebアプリケーション脆弱性診断ガイドライン 事例紹介 # 米金融大手Capital Oneにおいて、本記事にて説明しているSSRFの脆弱性を悪用されてしまった事例です。 AWS環境のWAF側の設定ミスにより、SSRFの脆弱性を攻撃によってAWS環境の認証情報を取得されて、S3バケットに格納されている個人情報が漏洩しました。 https://piyolog.hatenadiary.jp/entry/2019/08/06/062154\n対策 # 本問題の根本的な原因となるWebアプリケーションの脆弱性については、従来通り実装・設定などによるセキュリティ対策が必要となります。個々の既知のWebアプリケーションの脆弱性に対する対策方法の詳細については、本記事での説明は割愛します。\nまた、たとえばAWSにおいては以下のような設定変更を行うことで、根本的な対策ではありませんがSSRFの脆弱性に対する緩和策となることが知られています。\nIMDSv2 の使用\nhttps://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html 根本的な原因となる脆弱性への対策はもちろん必要となりますが、クラウド環境側から提供されているこのような緩和策の利用も併せて検討すべきでしょう。また、何らかの要因にて認証情報が漏洩することに備え、認証情報の不正利用に対して監視することも重要であると考えます。\n学習方法/参考文献 # SSRF(Server Side Request Forgery)徹底入門\nEC2上でDNS RebindingによるSSRF攻撃可能性を検証した\nSSRF対策としてAmazonから発表されたIMDSv2の効果と限界\n本記事にて説明したSSRFについて原理や対策方法について解説された徳丸浩さんのブログ記事です。また、本記事にて取り扱ったSSRFによるAWSの認証情報の取得についても解説されています。\nSSRF脆弱性を利用したGCE/GKEインスタンスへの攻撃例\nGCP環境におけるSSRFについて解説されているブログ記事です。\nExploiting SSRF in AWS Elastic Beanstalk\nAWS Elastic Beanstalk・AWS CodePipelineを利用している環境で、SSRFをトリガとして最終的にはRCEまで行うことができたNotSoSecure社の事例です。\nPenTesterが知っている危ないAWS環境の共通点\nAWS環境において漏洩した認証情報を利用した攻撃とその対策についてまとめているスライドです。\nflaws.cloud\nflaws2.cloud\nScott Piper氏(@0xdabbad00)が常設公開されているCTF形式でAWS固有のセキュリティトピックに関して学べるサイトです。\nCloudGoat\nAWSGoat\nGCPGoat\nAzureGoat\nクラウド環境にまつわる脆弱性を学習するために、脆弱なクラウド環境を構築するためのコンテンツが公開されています。\n"},{"id":11,"href":"/newtechtestdoc/docs/cloudsec/","title":"クラウドサービスにおけるWebサービスにまつわる脆弱性","section":"Docs","content":" クラウドサービスにおけるWebサービスにまつわる脆弱性 # 近年では、クラウドサービスを活用し、Webサービスを構築・提供しているという事例はもはや一般的となりました。 クラウドサービスを利用する上で注意すべき点として、利用者側がセキュリティを意識しなくても良いわけではないという点です。\nクラウドサービスにおいては、「責任共有モデル」という考え方が存在します。 「責任共有モデル」とは利用者側・クラウド事業者側の間で、それぞれがサービス提供における担当範囲を明確にし、運用上の責任を共有するという考え方です。\nAWSの責任共有モデル\nhttps://aws.amazon.com/jp/compliance/shared-responsibility-model/ 一般的な例でいえば、IaaS(Infrastructure as a Service)においてはクラウド事業者が提供するのはインフラ部分だけです。 IaaSの上に構築されるOSやミドルウェア、アプリケーション、データ等に関しては、利用者側が責任を持たなければなりません。 PaaS(Platform as a Service)であれば、インフラ・OS・ミドルウェアはクラウド事業者が提供します。 アプリケーション、データに関しては利用者側が責任を持たなければなりません。 上記のように、利用者とクラウド事業者の間で責任分担の境界線がしっかりと引かれており、利用者が責任を持つべき箇所が明確となっています。 これらの責任分界点については、クラウド事業者や提供するサービスによってそれぞれ定義が異なります。 なお、Cloud Security Alliance(CSA)からはコンテナやサーバレスアーキテクチャなどの比較的新しいサービス領域についてさらに細分化した責任共有モデルなども公開されています。\nThe Evolution of Cloud Computing and the Updated Shared Responsibility\nhttps://cloudsecurityalliance.org/blog/2021/02/04/the-evolution-of-cloud-computing-and-the-updated-shared-responsibility/ 利用者側が責任を持たなければならない範囲において、誤った実装や設定上のミスなどが存在した場合には、セキュリティ上の問題となってしまう可能性があります。 現実世界でも上記が起因となって発生したセキュリティインシデントが多数報告されています。 そのため、利用者側はこういった良くありがちなセキュリティ上の問題について理解し、正しい実装・設定や問題の発生を防止するために対策する必要があるでしょう。\n本記事では、「クラウドサービスを利用して構築しているWebサービスにおける誤った実装・設定不備などを起因としたセキュリティ上の問題点」について解説しています。 以下のカテゴリごとに問題点の概要・診断する際の観点・代表的ないくつかの事例について紹介しています。\nクラウドストレージサービスにおける設定不備 Webアプリケーションの脆弱性を利用したクラウドクレデンシャルの奪取 FaaSにおける設定不備と脆弱性の悪用 IDaaSの活用に起因する脆弱性とその悪用 "},{"id":12,"href":"/newtechtestdoc/docs/cloudsec/storage_service/","title":"クラウドストレージサービスにおける設定不備","section":"クラウドサービスにおけるWebサービスにまつわる脆弱性","content":" クラウドストレージサービスにおける設定不備 # 概要 # クラウドストレージサービスとは、インターネット上にてファイルの保管・共有などができるサービスです。 画像やJavaScriptファイルなどの静的ファイルを公開する用途などでも利用されています。 有名処のものとしては以下のようなサービスがあります。\nAWS S3 Azure Blob Storage Cloud Storage 近年ではこれらクラウドストレージサービスの設定ミスによるセキュリティインシデントが発生しています。\n原因と影響 # クラウドストレージサービスにおけるアクセス許可の設定不備が原因となり、意図しない情報がインターネット上に公開されてしまう可能性があります。 また、ファイルのアップロードが可能となっている場合には、公開しているコンテンツに悪意あるコードを埋め込まれ、攻撃に利用されてしまう可能性もあります。\n診断観点 # クラウドストレージの設定ミスを確認するシンプルな方法としては、クラウドストレージのエンドポイントに対応するURLへアクセスすることです。 そして、セキュリティ上問題となるような設定やコンテンツが公開されていないかを確認します。 本記事ではAWS S3を例として、脆弱性診断における本手法について説明します。\nS3バケットを示すエンドポイントのURLについて調査 # クラウドストレージを示すURLの形式に関する仕様は以下のように公開されています。\nAWS S3 Azure Blob Storage Cloud Storage ここではAWS S3について解説しますが、S3ではクラウドストレージのエンドポイントを示すURLは以下2種類のタイプが存在します。\n仮想ホスト形式\nhttp://\u0026lt;backet-name\u0026gt;.s3-\u0026lt;region\u0026gt;.amazonaws.com/ http://\u0026lt;backet-name\u0026gt;.s3.amazonaws.com/\n2019 年 3 月 20 日より後に開始されたリージョンで作成されたバケットでは2の形式(レガシーグローバルエンドポイント)では到達できないようです。 パス形式\nhttp://s3-\u0026lt;region\u0026gt;.amazonaws.com/\u0026lt;backet-name\u0026gt; http://s3.amazonaws.com/\u0026lt;backet-name\u0026gt;\n米国東部 (バージニア北部) リージョンは2の形式で、ほかのリージョンは1の形式となります。パス形式は将来的には廃止が検討されているようです。 上記の仕様を利用して、特定キーワードなどに関連するS3バケットのエンドポイントのURLを推測できます。 また、S3バケットにおいて独自ドメインを利用して、静的なサイトをホスティングする場合には、前提としてバケット名とドメイン名が一致しなければなりません。 このため、Webページのドメイン名などからもエンドポイントのURLを推測できます。\n特定のキーワードに関連するS3バケットを探索するようなツールも多数公開されています。\ns3recon s3finder また、公開状態のクラウドストレージやファイルの情報を定期的に収集し、検索できるオンラインサービスなども存在します。本サービスでは、S3だけではなくAzureやGCPなど他クラウドサービスの情報も検索できます。\nGrayhatwarfare 脆弱性診断の実施時には、HTMLソース・HTTPレスポンス・モバイルアプリケーションのソースコード内などに、S3バケットのURLや探索するためのキーワードが、存在しないかを確認すべきでしょう。 発見したキーワードをもとにクラウドストレージのエンドポイントを探索してみてください。 なお、探索によって存在が判明したS3バケットのエンドポイントのURLが診断対象の範囲に含まれるかどうかについては、調査する前にあらかじめ顧客やサイト管理者に対して確認するべきであると考えます。\nブラウザでの確認 # ブラウザ経由でアクセスして、S3バケットにおいてファイルの一覧の表示が許可されている場合には以下のようなXML形式のレスポンスが表示されます。\nこの設定状態の場合には、不特定多数へストレージ内に存在するファイルの内容が判明してしまうため、いわゆるディレクトリリスティングと同様の問題があるといえます。そのためこの設定状態が意図したものであるかを確認すべきでしょう。\nコマンドラインでの確認 # コマンドラインを用いて、クラウドストレージのファイルのダウンロードや、ファイルのアップロードについて確認できます。\nS3バケットであればAWS CLIを利用することで上記をテストできます。 S3においては、S3バケットのACLがAll Authenticated AWS Usersと設定されている可能性があります。 そのため、AWSユーザーとして認証された状態でもコマンドラインを実行する方が良いでしょう。\nS3バケットの内容を表示 aws s3 ls s3://\u0026lt;backet-name\u0026gt;/\u0026lt;path\u0026gt; S3バケットのオブジェクトを取得 aws s3 cp s3://\u0026lt;backet-name\u0026gt;/\u0026lt;objectname\u0026gt; \u0026lt;output file name\u0026gt; aws s3api get-object --bucket \u0026lt;bucket-name\u0026gt; --key \u0026lt;key name\u0026gt; \u0026lt;output file name\u0026gt; 設定ミスによって書き込みが可能となっている可能性があるため、以下のコマンドを利用してファイルの書き込みが可能であるかを確認できます。 ただし、脆弱性診断においては、書き込みをテストしてよいか事前に顧客側へ確認するべきであると考えます。\nローカルのファイルを指定して、指定したS3バケットにアップロード aws s3 cp \u0026lt;local file-path\u0026gt; s3://\u0026lt;bucket-name\u0026gt;/\u0026lt;path\u0026gt; aws s3api put-object --bucket \u0026lt;bucket-name\u0026gt; --key \u0026lt;key name\u0026gt; --body \u0026lt;local file-path\u0026gt; 事例紹介 # S3の設定不備に関するHacker Oneのレポート\nhttps://hackerone.com/reports/128088\nhttps://hackerone.com/reports/1062803\nhttps://hackerone.com/reports/129381\nS3設定不備により機密データが公開されていた事例\nhttps://www.skyhighsecurity.com/en-us/about/resources/intelligence-digest/unsecured-servers-can-put-lives-at-stake.html\nhttps://www.safetydetectives.com/news/doctorsme-leak-report/\nAzure Blob Storageの設定不備により機密データが公開されていた事例\nhttps://www.vpnmentor.com/blog/report-microsoft-dynamics-leak/ https://www.theregister.com/2020/12/01/investment_fund_data_breach/\nhttps://www.techradar.com/news/microsoft-azure-breach-left-thousands-of-customer-records-exposed\nhttps://www.bleepingcomputer.com/news/security/exposed-azure-bucket-leaked-passports-ids-of-volleyball-reporters/\nCloud Storageの設定不備により機密データが公開されていた事例\nhttps://www.comparitech.com/blog/information-security/google-cloud-buckets-unauthorized-access-report/\nファイルアップロードが可能となっているような設定ミスを攻撃者に悪用された事例\nhttps://japan.zdnet.com/article/35139832/\n対策 # 公開を意図しないクラウドストレージが存在しないように、アクセス制御の設定を適切に行うようにしてください。 また、公開を意図するクラウドストレージでは、機微な情報が含まれているファイルが存在しないか確認してください。\n学習方法/参考文献 # Amazon S3の脆弱な利用によるセキュリティリスクと対策\n上記は本記事にて解説しているアクセス制限の設定不備を含めた、S3にまつわる脆弱性について詳細に解説したブログ記事です。本記事では取り扱っていないWebアプリケーションでS3の署名付きURLを生成している場合に脆弱性が生じてしまう事例やS3におけるサブドメインの乗っ取りなどについても解説されています。\nHunting Azure Blobs Exposes Millions of Sensitive File\nAzure Blob Storage設定不備の調査方法に関する記事です。\n"},{"id":13,"href":"/newtechtestdoc/docs/web_cache_poisoning/","title":"Web Cache Poisoning","section":"Docs","content":" Web Cache Poisoning # 概要 # Web Cache Poisoningとは、Webサーバとキャッシュ(サーバ) の協調動作の欠陥を利用して、攻撃者が作成した悪意のあるレスポンスをキャッシュに注入する攻撃です。\nキャッシュとは # Webにおけるキャッシュとは、Webサーバとクライアントの間に存在します。キャッシュは再利用可能なレスポンスがキャッシュサーバに存在し、クライアントがそれを要求した場合、Webサーバへリクエストを転送せずにキャッシュサーバからレスポンスをクライアントに転送します。キャッシュサーバの存在によってWebサーバへのリクエスト数を減らすことができ、Webサーバへの負荷を減らすことができる技術です。\n影響 # Web Cache Poisoningを利用して攻撃を受けた場合、攻撃者によって作成された悪意のあるコンテンツを被害者が閲覧することになります。悪意のあるコンテンツはフィッシングに悪用されたり、悪意のあるファイルをダウンロードさせたりといったあらゆる攻撃に利用できます。また、悪意のあるコンテンツには以下のようなものを含むことがあり、それらがもたらす影響も同時に受けることを意味します。\nクロスサイトスクリプティング(XSS) HTML,CSS, JavaScriptインジェクション オープンリダイレクト など また、被害者のユーザに罠ページ経由で対象サイトにアクセスさせることにより、被害者の機微情報が含まれたページのキャッシュを生成させ、攻撃者がキャッシュを読み取るといった情報漏洩の影響も考えられます。\n原因 # キャッシュサーバの動作定義に不備がある場合、Web Cache Poisoning攻撃に利用される可能性があります。\n原因の大まかな例として「不適切なレスポンスをキャッシュしていること」、また「キャッシュを不適切なユーザに配信してしまうこと」等が挙げられます。本来、キャッシュは再利用可能なコンテンツを許可されたユーザに配信するべきものであるため、これらの制御に不備があるとWeb Cache Poisoningに対して脆弱となります。\n攻撃手法 # Web Cache Poisoning攻撃を実現するには複数の手順を踏む必要があります。また、その過程で攻撃可能な条件も決定されてきます。\n1. キャッシュのための「キーなし入力」を調査する # キャッシュは、コンテンツをユーザに返却するか、あるいはWebサーバにリクエストを転送するかの判断基準としてパスやヘッダなどを参照することがほとんどです。 キャッシュサーバ側では事前に定義されたキーと呼ばれるリクエストの要素を参照します。同じキーが存在した場合はリクエストに対応するコンテンツがキャッシュサーバに存在すると判断され、キャッシュサーバからコンテンツを返却します。\nそこで、キーなし入力を見つける必要があります。キーなし入力とはキャッシュサーバが無視するリクエストの要素です。たとえば、User-Agent ヘッダやX-Forwarded-Forヘッダなどはキーなし入力となることが多いです。これらの値が変化してもキャッシュサーバの挙動に変化はありません。キーなし入力を制御することによって、そのほかのキャッシュキーで構成されたリクエストが一致すれば、すべてのユーザに悪意のあるコンテンツを配信できるからです。\nキーなし入力の調査をするにはリクエストにさまざまな入力値を付与してその挙動を観察します。ヘッダ部分やリクエストのパスなどに入力を与えて応答がキャッシュされるかを調査します。キャッシュが有効にはたらく入力はキャッシュサーバやWebサーバによって異なるため、しばしば調査にはコストがかかります。多くの場合、ツールなどを用いてほかの脆弱性の調査をする過程でこのキーなし入力の調査をすることが多いです。よく利用されるツールとして、Burp Suiteプラグインである「Param Miner」が挙げられます。このプラグインはリクエストにさまざまなパラメータを付与し、キーなし入力を特定します。\n2. 悪意のあるコンテンツを生成させる # Webサイトがそのキーなし入力をどのように処理するのかを検証していきます。たとえば、その入力が適切にエスケープされていない場合はクロスサイトスクリプティングにつながる恐れがあります。パラメータへの検証はその悪意のあるコンテンツの種別によって手法が異なります。\nまた、機微情報を動的に生成する箇所で再現している場合、キーなし入力を被害者に強制させられるかも検証する必要があります。機密情報を含むキャッシュは被害者によって生成する必要があり、罠ページを経由して送信可能なリクエストの要素(ヘッダやパス、パラメータなど)だけで実現可能であるかが攻撃の成否につながります。\n3. レスポンスをキャッシュさせる # 最後に、悪意のあるコンテンツをキャッシュさせます。攻撃者が悪意のあるコンテンツを生成できても、それをキャッシュさせてターゲットとなるほかのユーザに閲覧してもらわなければ攻撃は成立しません。\nレスポンスがキャッシュされるかどうかはキャッシュサーバの挙動次第になります。パスに含まれる拡張子やContent-Type、レスポンスヘッダなどさまざまな要素に依存しています。\n悪意のあるコンテンツがキャッシュできたら、被害者にそのキャッシュに対してアクセスさせます。キャッシュは一定時間で有効期限が切れ、悪意のあるコンテンツが破棄されます。攻撃者はキャッシュの有効期限が入れても即座に再キャッシュさせるようなスクリプトを定期的に実行することで対応します。\n検証方法 # PortSwigger Web Security AcademyではWeb Cache Poisoningの検証が可能です。なお、サービス利用には無料ユーザ登録が必要になります。「Web cache poisoning with an unkeyed header」セクションではオーソドックスなWeb Cache Poisoningの検出が体験可能です。\n1. キーあり入力を付与 # 適当な商品詳細ページを開いてBurpSuiteのRepeaterへリクエストを登録し、キーあり入力を探索します。ページをキャッシュした際にキャッシュデータを識別するパラメータ要素を付与する必要があるからです。多くの場合、すでに付与されているクエリパラメータをそのまま利用したり、クエリ文字列などにわずかな文字列を付与するだけで十分です。たとえば、以下のようなクエリを与えます。\n/product?productId=1\u0026amp;cache=1234\n2. キーなし入力の探索 # 次に、キーなし入力を探索します。攻撃手法のセクションで解説した通り、キャッシュサーバが無視するリクエストの要素を探します。X-Forward-Header や User-Agent などがキーなし入力として利用可能なケースが多いですが、Param Minerを利用してキーなし入力を発見できます。 BurpSuiteのExtenderでParam MinerをBApp Store経由でインストールします。 スキャン対象のリクエストを右クリック→Extensions→ParamMiner→Guess params→Guess headersを選択します。\n設定は特に変更せずOKを選択してスキャンを開始します。 Extenderタブ→Extensions で、Param Minerを選択して、Outputタブを開きます。 「Queued 1 attacks」と表示され、スキャンが始まります。一定時間経過すると、スキャン結果が表示されます。\n今回は X-Forwarded-Host や Originヘッダが検出されました。Repeaterに戻って X-Forwarded-Hostヘッダを付与してみます。\nヘッダの値がレスポンスに反射しました。さらに、X-Forwarded-Hostを削除して再度リクエストを送信します。\nヘッダを付与していないにもかかわらず同じレスポンスが返却されました。 これは、クエリ文字列などに与えたキーをもとにレスポンスがキャッシュされたためです。レスポンスヘッダには「X-Cache: hit」が出力されていることも確認できます。 最後に、キーなしヘッダを自身が管理するサーバや、Portswiggerが提供するexploit serverに置き換えて、不正なJavaScriptを配信できるキャッシュを生成させます。 攻撃者は何らかの方法で同じキーを持つURLを被害者にアクセスさせることで不正なスクリプトを実行できます。\n利用ツール # Param Miner 事例紹介 # https://hackerone.com/reports/1424094 https://hackerone.com/reports/1010858 対策 # 最も効果のある対策としては、キャッシュ機能やサーバを無効化することです。すべてWebアプリケーションがコンテンツを都度生成し、配信することでWeb Cache Poisoningの脅威はなくなります。\nしかし、本来利便性を上げるための機構であるキャッシュサーバを無効化することは現実的でない場合があります。特に大規模なサイトが多くのリクエストを処理できるのは、キャッシュの存在が大きく貢献しています。この場合は、静的コンテンツにのみキャッシュを適用させ、動的コンテンツはキャッシュさせないようにすることが対策になります。\n学習方法/参考文献 # https://portswigger.net/Web-security/Web-cache-poisoning/exploiting-design-flaws/lab-Web-cache-poisoning-with-an-unkeyed-header https://portswigger.net/Web-security/Web-cache-poisoning "}]