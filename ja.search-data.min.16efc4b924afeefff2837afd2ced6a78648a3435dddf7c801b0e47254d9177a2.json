[{"id":0,"href":"/docs/sample/","title":"Sample1","section":"Docs","content":" Sample1 # aaa\n"},{"id":1,"href":"/prototype_pollution/","title":"Prototype Pollution","section":"Introduction","content":" Prototype Pollution # 概要 # Prototype Pollution は、JavaScript において主に\u0026quot;継承\u0026quot;を実現するために用いられる、__proto__プロパティを通じて特定のオブジェクトの内容を不正に変更する攻撃手法またはそれに対する脆弱性です。\n影響 # Prototype Pollution の影響は様々で、発生箇所やアプリケーションのロジックに依存します。 最悪の場合ではサーバサイドでの任意コード実行に繋がることがあり、その他の場合では XSS や SQL インジェクションなどの脆弱性にも繋がる可能性があります。\n原因 # 攻撃者が__proto__プロパティなどを経由して、特定のオブジェクトの prototype を操作可能であることが Prototype Pollution の原因です。\n攻撃手法 # 実際にオブジェクトの__proto__プロパティが操作可能なケースとして、下記 2 つの例を紹介します。\nオブジェクトに対して merge や clone の操作を行うケース setValue(obj, key, value)のようにオブジェクトのプロパティを設定するケース 1. オブジェクトに対して merge や clone の操作を行うケース # 以下のmerge(tgt, src)は、引数のtgtオブジェクトにsrcのプロパティを再帰的にマージします。 この実装では与えられたオブジェクトのkeyの値をチェックしておらず、任意のkeyに対して任意の値を代入できます。(10 行目)\nfunction isObject(obj) { return obj !== null \u0026amp;\u0026amp; typeof obj === \u0026#39;object\u0026#39;; } function merge(tgt, src) { for (let key in src) { if (isObject(tgt[key]) \u0026amp;\u0026amp; isObject(src[key])) { merge(tgt[key], src[key]); } else { tgt[key] = src[key]; } } return tgt; } merge( {a: 1, b: 2}, JSON.parse(\u0026#39;{\u0026#34;__proto__\u0026#34;: {\u0026#34;polluted\u0026#34;: 1}}\u0026#39;) ); const obj = {}; console.log(obj.polluted); // =\u0026gt; 1 上記の PoC では、引数srcに{\u0026quot;__proto__\u0026quot;: {\u0026quot;polluted\u0026quot;: 1}}というオブジェクトを渡しており、10 行目でtgt[__proto__] = {\u0026quot;polluted\u0026quot;:1}のような代入が実行されることで攻撃が成功しています。\n2. setValue(obj, key, value)のようにオブジェクトのプロパティを設定するケース # 以下のsetValue(obj, key, value)は、引数のobjオブジェクトに{key:value}のプロパティを追加します。また、keyにチェーン演算子を用いて指定することで深くに位置するプロパティを追加します。\nこの実装でも引数keyの値をチェックしておらず、任意のkeyに対して任意の値を代入できます。(13 行目)\nfunction isObject(obj) { return obj !== null \u0026amp;\u0026amp; typeof obj === \u0026#39;object\u0026#39;; } function setValue(obj, key, value) { const keylist = key.split(\u0026#39;.\u0026#39;); const e = keylist.shift(); if (keylist.length \u0026gt; 0) { if (!isObject(obj[e])) obj[e] = {}; setValue(obj[e], keylist.join(\u0026#39;.\u0026#39;), value); } else { obj[key] = value; return obj; }} setValue({}, \u0026#34;__proto__.polluted\u0026#34;, 1); const a = \u0026#34;\u0026#34;; console.log(a.polluted); // =\u0026gt; 1 上記の PoC では、引数keyに__proto__.pollutedという値を渡しており、再帰的に処理されることで結果的に 13 行目でobj[__proto__][polluted] = 1のような代入が実行されることで攻撃が成功しています。\n事例紹介 # NVD - cve-2019-7609 #1106238 Stored XSS via Mermaid Prototype Pollution vulnerability #454365 Prototype pollution attack through jQuery $.extend 対策 # Prototype Pollution の対策にはいくつか方法があるため、アプリケーションの規模や副作用を考慮して、適当な対策を選択するようにしてください。 ここでは代表的な下記 5 つの方法を紹介します。\nライブラリを利用する方法 Object.freezeを使用する方法 Objectの代わりにMapを使う方法 オブジェクトの作成をObject.create(null)で行う方法 Schema validation of JSON input ライブラリを利用する方法 # 要件を満たす場合、Prototype Pollution の影響を受けずにオブジェクトに対して merge や clone を行うライブラリを利用することで防ぐことができます。\nObject.freezeを使用する方法 # Object.freeze()を使用して、Object や Object.prototype を変更できないようにすることで、prototype が意図せず汚染されないようにできます。\n下記のコードは、実際にObject.freeze()を使用して実際に対策できることを示す PoC です。\nObject.freeze(Object.prototype); Object.freeze(Object); ({}.__proto__.test = 123); console.log({}.test); // =\u0026gt; undefined なお、注意点として、（上記の PoC を実際に動かしてみてもわかる通り、）Object.freeze()によって freeze されたオブジェクトの変更は、特にエラーや例外が起こることなく失敗します。 そのため、本対策を適用し意図しない副作用が発生した場合でも、その副作用を発見するのが困難な場合があります。 したがって、この対策は（依存ライブラリを含めた）アプリケーションの現状の実装を考慮して、慎重に適用することを推奨します。\nObjectの代わりにMapを使う方法 # ES6 以降では、Objectの代わりにMapが利用できます。 Objectを単純に key/value のデータ構造を利用している場合は、それらをMapに置き換えることで、Prototype Pollution を防ぐことができます。\nオブジェクトの作成をObject.create(null)で行う方法 # Object.create()にnullを渡す方法で、prototype を引き継がないオブジェクトを作成することで、__proto__経由で prototype が汚染されることを防ぐことができます。 下記のようなコードで、実際に__proto__経由で prototype にアクセスできないことを実際に確認できます。\nvar obj = Object.create(null); console.log(obj.__proto__ === Object.prototype); // =\u0026gt; false console.log(obj.__proto__); // =\u0026gt; undefined もし{\u0026quot;a\u0026quot;: 1, \u0026quot;b\u0026quot;: 2}のような元々いくつかのプロパティを持つオブジェクトを作成する場合は、下記のようにObject.assign()を併せて利用する必要があります。\nvar obj = Object.assign(Object.create(null), { a: 1, b: 2 }); なお、このように作成されたオブジェクトの prototype はObject.prototypeの参照ではないため、hasOwnProperty()のようなObject.prototypeのメソッドはプロトタイプチェーン経由で呼び出せません。 もし、そのようなメソッドを呼び出したい場合はObject.prototype.hasOwnPropertyのように明示的に行う必要があります。\nvar obj = Object.create(null); obj.a = 1; Object.prototype.hasOwnProperty.call(obj, \u0026#34;a\u0026#34;); // =\u0026gt; true Object.create(null)による本対策を適用する場合は、このような副作用に留意してください。\nSchema validation of JSON input # JSON SchemaではadditionalProperties:falseを指定することで、想定していないプロパティを禁止することができます。 適切な JSON Scheme を用いてバリデーションを行うことで Prototype Pollution の対策ができます。\n以下は、前述の関数setValue()に対し、ajvを用いて対策を行う例です。\nconst schema = { type: \u0026#34;object\u0026#34;, properties: { // 想定しているプロパティ }, additionalProperties: false, }; const validate = ajv.compile(schema); function setValue(obj, key, value) { const keylist = key.split(\u0026#34;.\u0026#34;); const e = keylist.shift(); if (keylist.length \u0026gt; 0) { if (!isObject(obj[e])) obj[e] = {}; setValue(obj[e], keylist.join(\u0026#34;.\u0026#34;), value); } else { obj[key] = value; if (!validate(obj)) { // handling throw \u0026#34;Invalid Obj\u0026#34;; } return obj; } } setValue({}, \u0026#34;__proto__.polluted\u0026#34;, 1); // =\u0026gt; Exception raised ただし、この場合、propertiesに含んでいないプロパティは一切追加ができなくなることに注意が必要です。 任意のプロパティを受け入れつつ対策をする場合、単に追加される key に悪意のある値が指定されないように制限する対策も有効です。\nfunction setValue(obj, key, value) { const keylist = key.split(\u0026#34;.\u0026#34;); const e = keylist.shift(); if (keylist.length \u0026gt; 0) { if (!isObject(obj[e])) obj[e] = {}; if (e !== \u0026#34;__proto__\u0026#34; \u0026amp;\u0026amp; e !== \u0026#34;constructor\u0026#34;) { setValue(obj[e], keylist.join(\u0026#34;.\u0026#34;), value); } } else { obj[key] = value; return obj; } } setValue({}, \u0026#34;__proto__.polluted\u0026#34;, 1); const a = \u0026#34;\u0026#34;; console.log(a.polluted); // =\u0026gt; undefined 診断方法 # 基本的な診断方法 # これまでに説明した Prototype Pollution の基本原理や攻撃手法などを踏まえ、任意のオブジェクトの prototype が不正に変更できないかを検証してください。\nDOM Invader を用いた効率的な診断 # DOM Invader は Burp の機能で DOM XSS のテストやpostMessage()の操作を用いたテストの支援を提供します。この機能を用いることでクライアントサイドの Prototype Pollution の自動検出や手動での検証の補助として利用可能です。\n詳しい検証方法はTesting for client-side prototype pollutionで丁寧に解説されているので、こちらを参照してください。\n学習方法/参考文献 # HoLyVieR/prototype-pollution-nsec18: Content released at NorthSec 2018 for my talk on prototype pollution Olivier Arteau \u0026ndash; Prototype pollution attacks in NodeJS applications - YouTube Node.js における prototype 汚染攻撃への対策 - SST エンジニアブログ 【1 分見て】実例から学ぶ prototype pollution【kurenaif 勉強日記】 - YouTube Prototype pollution: The dangerous and underrated vulnerability impacting JavaScript applications | The Daily Swig BlackFan/client-side-prototype-pollution: Prototype Pollution and useful Script Gadgets Object.prototype.proto - JavaScript | MDN "},{"id":2,"href":"/attack_a/","title":"Template","section":"Introduction","content":" Sample1 # Sample1.1 # aaaa\nSample2 # bbbb\nSample1 # cccc\n"},{"id":3,"href":"/attack_b/","title":"Template","section":"Introduction","content":" Sample1 # Sample1.1 # aaaa\nSample2 # bbbb\nSample1 # cccc\n"},{"id":4,"href":"/docs/template/","title":"Template","section":"Docs","content":" Sample1 # aaa\nSample1.1 # aaaa1111\nSample1.2 # 22222\nSample1.2.1 # 2222bbbb\nSample1.3 # 33333\n"},{"id":5,"href":"/toctou/","title":"Template","section":"Introduction","content":" TOCTOU/レースコンディション # 概要 # システム開発のセキュリティにおいてレースコンディションとTOCTOUは、しばしば混同して使われることがありますが、それぞれの違いについて用語の整理から確認していきましょう。\nレースコンディション(race condition)とは、複数の処理が同じデータに対して同時にアクセスしたときに競合状態になることで、想定外の処理が引き起こされる問題です。\n対してTime Of Check To Time Of Use(TOCTOU)とは、あるデータを使用する際に、データの状態をチェックする処理から実際にそのデータを使用する処理するまでの間に、データの状態が変化してしまうことで想定外の処理が引き起こされる問題です。\n要約すると、レースコンディションは様々な競合状態の問題を表す包括的な脆弱性なのに対し、TOCTOUはより実装の状況を限定した具体的な脆弱性であることが分かります。\n本章では、主にTOCTOUに関連する脆弱性や攻撃手法について説明します。\n原因 # TOCTOUは主にデータのチェックとそのデータの使用するタイミングが異なっていることに起因しています。 そのため、TOCTOUを対策する考え方としては、データのチェックと使用を同時に行い、処理の差を発生させないようにすることが理想的です。\n影響 # 代表的な脅威の例として、許可されていないデータへのアクセスや、回数制限などを超えて実行することを許してしまうような影響が考えられますが、データの内容や重要性、アプリケーションの振る舞いなどのビジネスロジックによってTOCTOUによる影響範囲は大きく異なります。\nここでは、TOCTOUが発生しやすい機能を例にあげます。\n送金処理 クーポンやキャンペーンコード等の発行や使用 アカウントの新規登録 高評価、いいねボタンなどの投票機能 診断観点/攻撃手法 # 一般的に、DASTのようなツールを使用してTOCTOUの脆弱性を特定することは困難です。\nこれは、競合状態を引き起こした状態と正常なWebアプリケーションの振る舞いの違いを機械的に判断することは難しいためです。\nまた、TOCTOUの検査を行うためにはミリ秒単位で調整されたリクエスト送信や単一のHTTPパイプライン内で複数のHTTPリクエストを送る検査が必要になってくるため、Webアプリケーション診断に特化した専門ツール(Burpなど)が必要になるでしょう。\nこのように、競合状態を起こすための条件や環境を整える必要がある性質上、手動によるテストも他のWebアプリケーション脆弱性検査に比べて検査が難しいと考えられています。\nTOCTOUの脆弱性を見つけるためには、データのチェック処理とデータを使用する処理が別のタイミングで行われている箇所を探しましょう。\n具体的には、実行回数に制限があるような機能や重複防止の制限が設けられている機能などでTOCTOUの検査を行うことが有用です。\nBurp Intruderを使用した検査 # Burp Intruderを使用してTOCTOUの検査を確認するパターンを紹介します。Burp IntruderはBurpに搭載されている機能の一つですが、Community Editionには機能制限があるためPro Editionでしか検査が行えません。Community Editionを使用する場合は、後述するTurbo Intruderを使用した検査方法をご覧ください。\nはじめに、送信したいリクエストをBurp Intruderにセットします。\nBurp Intruderを開始するにはペイロードポジションを設定する必要がありますが、ペイロードによる作用を防ぐため、ここではダミー用のリクエストヘッダー(x-dummy)を用意し、ダミー用ヘッダーの値にペイロードポジションを設定します。\n次に、ペイロードの設定を行います。\nPayload TypeをNull payloadsに設定します。\nGenerateの空白欄に送信したいリクエスト数を入力します。\nデフォルトでは同時に10リクエストを送信します。\nより多くのリクエストを送信したい場合は、Resource Pool設定から新しいリソースプール設定を作成し、Maximum concurrent requestsを設定してください。\nTurbo Intruderを使用した検査 # Burp Suiteの拡張機能として公開されているTrubo Intruderを使用したパターンを紹介します。\nTurbo Intruderは、大量のHTTPリクエストを送信したり、Pythonを使用して柔軟にリクエスト前後の処理を操作することができる拡張機能です。\nまた、Turbo Intruderは、標準のBurp Intruderとは異なりCommunity Editionでも使用することが可能です。\n注意\nTurbo Intruderは、Port Swigger社のセキュリティリサーチャーであるJames Kettle氏によって開発されていますが、十分なテストが行われていないためBurpの標準機能よりも信頼性がなく、システムパフォーマンスに影響を及ぼす可能性があるため、拡張機能を使用される際には自己責任でお願い致します。 送信したいリクエストを選択し、コンテキストメニューからExtensions-\u0026gt;Turbo Intruder-\u0026gt;Send to turbo intruderをクリックして、Turbo Intruderへリクエストを送ります。\n別のウィンドウが表示されます。\nTurbo IntruderもBurp Intruderと同様にペイロードポジションを設定する必要があります。ここではダミー用のリクエストヘッダー(x-dummy)を用意し、ダミー用ヘッダーの値に%sをセットしてペイロードポジションを設定します。\n次にドロップダウンリストから「examples/race.py」を選択します。\nデフォルトでは同時に30リクエスト送信する設定になっています。例として10リクエスト送信したい場合は、9行目のrange関数の引数を修正します。\n事例紹介 # https://github.com/reddelexc/hackerone-reports/blob/master/tops_by_bug_type/TOPRACECONDITION.md 対策 # データの整合性を保つ設計を行う必要があります。しかしながら、Webアプリケーション毎によって実装やデザインが異なるため、具体的な方法は多岐に分かれます。\n考えられる対策として、データのチェックからデータ更新までの一連の処理が完了するまで、他のスレッドやプロセスからアクセスできないようにしてください。\nデータベースで管理している場合はトランザクションを行い、読み書きする情報にロックを掛ける実装にしてください。\nただし、ロックの範囲が広すぎると脆弱性発生箇所とは異なる箇所でデッドロックが発生したり、トランザクション処理によってパフォーマンスにも影響を及ぼす可能性があるため注意してください。\n学習方法/参考文献 # https://timegaptheory.com/index.html "},{"id":6,"href":"/cloudsec/","title":"クラウドサービスにおけるWebサービスにまつわる脆弱性","section":"Introduction","content":" クラウドサービスにおけるWebサービスにまつわる脆弱性 # 近年では、クラウドサービスを活用し、Webサービスを構築・提供しているという事例はもはや一般的となりました。 クラウドサービスでは、クラウド事業者側がセキュリティを担保してくれるため、利用者側は特にセキュリティを意識しなくても良いと思われるかもしれませんが、残念ながらそうではありません。\nクラウドサービスにおいては、「責任共有モデル」という考え方が存在します。 「責任共有モデル」とは利用者側・クラウド事業者側の間で、それぞれがサービス提供における担当範囲を明確にし、運用上の責任を共有するという考え方です。\nAWSの責任共有モデル\nhttps://aws.amazon.com/jp/compliance/shared-responsibility-model/ 一般的な例でいえば、IaaS(Infrastructure as a Service)においてはクラウド事業者が提供するのはインフラだけとなり、IaaSの上に構築されるOSやミドルウェア、アプリケーション、データ等に関しては、利用者側が責任を持たなければなりません。 一方PaaS(Platform as a Service)であれば、インフラ・OS・ミドルウェアはクラウド事業者が提供しますが、アプリケーション、データに関しては利用者側が責任を持たなければなりません。 上記のように、利用者とクラウド事業者の間で責任分担の境界線がしっかりと引かれており、利用者が責任を持つべき箇所が明確となっています。 これらの責任分界点については、クラウド事業者や提供するサービスによってそれぞれ定義が異なります。 なお、Cloud Security Alliance(CSA)からはコンテナやサーバーレスアーキテクチャなどの比較的新しいサービス領域についてさらに細分化した責任共有モデルなども公開されています。\nThe Evolution of Cloud Computing and the Updated Shared Responsibility\nhttps://cloudsecurityalliance.org/blog/2021/02/04/the-evolution-of-cloud-computing-and-the-updated-shared-responsibility/ 利用者側が責任を持たなければならない範囲において、誤った実装や設定上のミスなどが存在した場合には、セキュリティ上の問題となってしまう可能性があります。 現実世界でも上記が起因となって発生したセキュリティインシデントが多数報告されています。 そのため、利用者側はこういった良くありがちなセキュリティ上の問題について理解し、正しい実装・設定や問題の発生を防止するための施策を行う必要があるでしょう。\nここでは、「クラウドサービスを利用して構築しているWebサービスにおける誤った実装・設定不備などを起因としたセキュリティ上の問題点」について、近年話題となっている代表的ないくつかの事例を紹介しています。\nクラウドストレージサービスにおける設定不備 Webアプリケーションの脆弱性を利用したクラウドクレデンシャルの奪取 FaaSにおける設定不備と脆弱性の悪用 IDaaSの活用に起因する脆弱性とその悪用 "}]